<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis为什么要自己实现SDS</title>
    <url>/2020/01/21/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0SDS/</url>
    <content><![CDATA[<h3 id="Redis-为什么要自己实现一个-SDS？"><a href="#Redis-为什么要自己实现一个-SDS？" class="headerlink" title="Redis 为什么要自己实现一个 SDS？"></a>Redis 为什么要自己实现一个 SDS？</h3><h4 id="原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快"><a href="#原因一：SDS-获取字符串长度的时间复杂度比用-C-语言的字符数组实现的字符串要快" class="headerlink" title="原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快"></a>原因一：SDS 获取字符串长度的时间复杂度比用 C 语言的字符数组实现的字符串要快</h4><p>用 C 的字符数组实现的字符串在获取字符串长度时需要遍历整个字符数组，然后把每个字符进行计数，直到遇到空字符（<code>&#39;\0&#39;</code> ） 才停止计数得出字符串的长度，这样的时间复杂度为 <code>O(N)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/486a41e3-fc8c-51b1-8012-673b9b65bed0.png" alt="图片丢失" title="图1"></p>
<p>而 SDS 在 <code>len</code> 属性中记录了字符串的长度，所以获取字符串的长度就相当于获取 <code>len</code> 的值，时间复杂度为 <code>O(1)</code></p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//17e4cc89-1869-5162-a86d-a4521526be76.png" alt="图片丢失"></p>
<h4 id="原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出"><a href="#原因二：用-C-语言字符数组实现的字符串容易造成缓冲区溢出" class="headerlink" title="原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出"></a>原因二：用 C 语言字符数组实现的字符串容易造成缓冲区溢出</h4><p><code>string.h</code> 库的 <code>strcat</code> 函数将 <code>src</code> 字符串中的类容拼接到 <code>dest</code> 字符串的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure>
<p>因为用 C 语言的字符数组实现的字符串不记录自身的长度，所以假定用户在执行 <code>strcat</code> 函数时，已经为 <code>dest</code> 分配足够多的内存空间，则可以容纳 <code>src</code> 字符串的所有内容，而一旦这个假设不成立，就会产生内存溢出</p>
<p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code> ， 如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//6b53d401-6a33-5d9d-b3c3-d9fc2cf11344.png" alt="图片丢失" title="图2"></p>
<p>在这种情况下如果执行如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>s1</code> 后面追加 <code>&quot; Cluster&quot;</code> ，但是<code>s1</code>的原有的空间不足，也未为 <code>s1</code> 重新分配足够的空间导致在执行 <code>strcat</code> 函数后 <code>s1</code> 的数据直接溢出到 <code>s2</code> 所在的内存空间中，最终导致 <code>s2</code> 的内容意外地被篡改，结果如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//fbd60a7d-1cd6-5380-8dda-765e517d2875.png" alt="图片丢失" title="图3"></p>
<p>而 SDS 和 C 语言实现的字符串不同，SDS API 对 SDS 进行修改时 API 会先检查 SDS 的空间是不是满足修改所需的要求，如果不满足，API 会自动将 SDS 的空间扩展到执行修改所需要的空间大小，然后再执行修改操作，所以使用 SDS 不需要手动修改 SDS 的空间大小也不会出现和 C 语言字符串那样的缓冲区溢出的问题</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 <code>sdscat</code> 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， <code>sdscat</code> 会先检查给定 SDS 的空间是否足够， 如果不够的话， <code>sdscat</code> 就会先扩展 SDS 的空间， 然后才执行拼接操作</p>
<p>比如说， 如果我们执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s, <span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>SDS 的 <code>s</code> 的结构如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt="图片丢失" title="图4"></p>
<p><code>sdscat</code>在执行拼接操作前会检查 <code>s</code> 的内存空间长度是否足够拼接 <code>&quot; Cluster&quot;</code> ，在发现 <code>s</code> 的空间长度不足够拼接 <code>&quot; Cluster&quot;</code> 后，会先扩展 <code>s</code> 的内存空间，然后再执行拼接操作，拼接后的 <code>s</code> 如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt="图片丢失" title="图5"></p>
<p>并且 <code>sdscat</code> 这个函数不仅对这个 SDS 进行了拼接操作，还对 SDS 分配了 13 字节的未使用空间，并且拼接之后的字符串也正好是 13 个字节，这种现象和 SDS 的空间分配策略有关</p>
<h4 id="原因三：减少修改字符串时带来的内存重新分配次数"><a href="#原因三：减少修改字符串时带来的内存重新分配次数" class="headerlink" title="原因三：减少修改字符串时带来的内存重新分配次数"></a>原因三：减少修改字符串时带来的内存重新分配次数</h4><p>因为用 C 语言实现的字符串不记录自身的长度，所以对于一个包含 N 个字符的 C 语言字符串来说，这个 C 语言字符串的底层实现总是一个 N+1 长度的字符数组 （额外的一个字符用于保存空字符 <code>&#39;\0&#39;</code>)，因为 C 字符串和底层字符数组的这种关联性，所以每次缩短和增加字符串 C 语言实现的字符串时需要对实现 C 语言字符串的底层字符数组重新进行一次内存分配</p>
<ul>
<li><p>如果程序执行的是增长字符串的操作，那么在执行该操作之前需要先重新进行一次内存分配来扩展底层的字符数组，如果忘了会导致缓冲区溢出</p>
</li>
<li><p>如果程序执行的是缩短字符串的操作，那么在执行该操作之后需要重新进行一次内存分配释放那些不再使用的那部分空间，如果忘了会导致内存泄漏</p>
</li>
</ul>
<p>举个例子，如果要将一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串 s 改为 <code>&quot;Redis Cluster&quot;</code>，在执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之前，我们需要先使用内存分配操作，扩展 s 空间</p>
<p>因为内存重新分配算法涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重新分配是可以接受的，但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重新分配的话，那么光是执行的内存重新分配的时间就占去修改字符串所有时间的一部分，如果这种修改频繁的发生的话，可能会影响性能，所以 Redis 为了避免 C 字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中，buf 数组的长度不一定是字符数量加一，数组中包含了未使用的字节，而这些未使用字节的数量就由 SDS 的 <code>free</code> 属性记录</p>
<p>通过未使用空间 SDS 实现了空间预分配和惰性空间释放着两个优化策略</p>
<h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 API 需要对 SDS 进行修改并且这个修改需要扩展 SDS 的空间的时候，程序不仅会为 SDS 分配修改所需要的空间，还会为 SDS 分配额外的未使用空间</p>
<p>分配额外空间会根 z 据不同的的情况选择不同的策略，分配策略如下：</p>
<ul>
<li><p>如果对 SDS 进行修改之后，SDS 中 <code>len</code> 属性的值小于 <code>1</code> MB，这时程序会为 SDS 分配和 <code>len</code> 属性值一样大小的未使用空间，这时 <code>len</code> 的值和 <code>free</code> 的值是一样的，举个例子，SDS 进行扩展后， SDS 的 <code>len</code> 属性值为 <code>13</code> ，那么程序会为 SDS 分配和 <code>len</code> 属性值一样大小的 <code>13</code> 个字节的未使用空间 ，最终 <code>free</code> 的值为 <code>13</code> ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>27</code> byte(13+13+1=27,额外的自字节用于保存空字符)</p>
</li>
<li><p>如果对 SDS 进行修改之后，SDS 的 <code>len</code> 属性的值大于等于 <code>1</code> MB，这是程序会为 SDS 分配 <code>1</code> MB 的未使用空间，举个例子，SDS 进行修改后，SDS 的 <code>len</code> 的值为<code>30</code>MB，那么程序会为 SDS 分配<code>1</code> MB 的未使用空间，最终 <code>free</code> 的值为 <code>1</code> MB ，SDS 的 <code>buf</code> 数组的长度大小变为 <code>30</code>MB + <code>1</code> MB + <code>1</code> byte</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在执行 <code>sdscat</code> 进行拼接之前需要检查 <code>s</code> 的长度是否足够，发现 <code>s</code> 的长度不够拼接 <code>&quot; Cluster&quot;</code>，<code>sdscat</code> 就会先扩展 <code>s</code> 的空间，然后才执行拼接 <code>&quot; Cluster&quot;</code>的操作</p>
<p>拼接前的 SDS 结构如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//5dfb78a7-5103-5fc5-8bbe-b84346a9a8c3.png" alt="图片丢失" title="图6"></p>
<p>拼接后的 SDS 的结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img//8b5dceef-e0ca-523b-a431-1b73c23481d0.png" alt="图片丢失" title="图7"></p>
<p>如果这时在对 <code>s</code> 进行如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Tutorial&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么这次 <code>sdscat</code> 执行的时候 就不需要重新分配内存，因为未使用空间里面的 <code>13</code> 个字节可以保存 <code>9</code> 个字节的 <code>&quot; Tutorial&quot;</code> ,函数执行完后的 SDS 的结构图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/600c714b-f1aa-51e7-b3e2-41c9bebbd790.png" alt="图片丢失" title="图8"></p>
<p>在扩展 SDS 前会先检查 SDS 的 未使用空间是否已经足够扩展所需要的空间，如果未使用空间足够就直接使用未使用空间，而无需执行内存重新分配的操作，通过这种分配策略，SDS 将连续增长 N 次字符串所需的内存重新分配次数必定为 N 次减低为最多为 N 次</p>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重新分配来回收缩减多出来字节，而是使用 <code>free</code> 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>举个例子，<code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符串</p>
<p>如下面对 SDS 值 s 执行 <code>sdstrim</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdstrim(s,<span class="string">&quot;XY&quot;</span>); <span class="comment">// 移除 SDS 字符串中的所有 &#x27;X&#x27; 和 &#x27;Y&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行字符串缩减前的 SDS 如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/63d24217-4e56-4f58-a7c0-ff90a4b2e73a.png" alt="图片丢失" title="图9"></p>
<p>执行 <code>sdstrim</code> 对 SDS 值 <code>s</code> 进行缩减后的结构图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/636d5b62-c44f-5c9a-a5f4-b4d32befb844.png" alt="图片丢失" title="图10"></p>
<p>注意执行 <code>sdstrim</code> 之后的 SDS 并没有释放多出来的 <code>8</code> 个字节的空间，而是将这 <code>8</code> 个字节空间作为未使用的空间保留在 SDS 中，如果将要对 SDS 进行增长操作的话，这些未使用空间就可能派上用场</p>
<p>举个例子，对上面执行完 <code>sdstrim</code> 操作后的 <code>s</code> 执行 <code>sdscat</code> 操作增长操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdscat(s,<span class="string">&quot; Redis&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>那么完成这次 <code>sdscat</code> 操作将不需要执行内存分配因为 SDS 里面预留的 <code>8</code> 个字节的空间已经足以拼接 <code>6</code> 个字节的 <code>&quot; Redis&quot;</code> ，拼接后的结构图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/2809aa3e-8279-571c-b030-8c75e1e77f2d.png" alt="图片丢失" title="图11"></p>
<p>通过惰性空间分配释放策略，SDS 避免了缩短字符串是所需要的内存重新分配操作，并且将来可能为增长操作提供优化</p>
<p>与此同时，SDS 也提供了相应的 API ,让我们可以在需要的时候，真正的释放 SDS 里面的未使用空间，所以不需要担心惰性空间策略造成的内存浪费</p>
<h4 id="原因四：二进制安全"><a href="#原因四：二进制安全" class="headerlink" title="原因四：二进制安全"></a>原因四：二进制安全</h4><p>C 语言字符串中的字符必须符合某种编码（比如 ASCII）,并且出了字符串的末尾之外，字符串的其他地方不能包含空字符（<code>&#39;\0&#39;</code> ），否者最先被程序读入的空字符串会被误认为字符串的结尾，这样导致了 C 语言字符串自能保存文本，不能保存图片、音频、视频、压缩文件这样的二进制数据</p>
<p>举个例子，如果有一个使用空字符分割多个单词的特殊数据格式，结构如下图，那么这种格式就不适合用 C 字符串保存，因为 C 字符串的函数只能识别出空字符（<code>&#39;\0&#39;</code> ）前面的 <code>Redis</code> 而它后面的 <code>&quot;Cluster&quot;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/4f7dab93-d3df-5066-b3c7-0d7779acaa4d.png" alt="图片丢失" title="图12"></p>
<p>虽然数据库一般保存的是文本数据，但是使用数据库保存二进制数据的场景也不少见，因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的：所有的 SDS API 都会处理二进制的方式处理 SDS 存在 <code>buf</code> 数组中的数据，数据写入的时候是上面样的，它读出来就是上面样的</p>
<p>这就是我们为什么将 SDS 的 <code>buf</code> 属性称为字节数组的原因，因为 Redis 不用这个数组保存字符，而是用来保存一系列的二进制数据</p>
<p>所以使用 SDS 保存上面提到的特殊格式的字符串是没有任何问题，因为 SDS 时使用 <code>len</code> 属性来判断字符串是否结束的，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/24d91093-b1f8-551e-8c3d-771d65061f87.png" alt="图片丢失" title="图13"></p>
<p>通过使用二进制安全的 SDS ，而不是 C 字符串，使得 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<h4 id="原因五：兼容部分-C-语言字符串函数"><a href="#原因五：兼容部分-C-语言字符串函数" class="headerlink" title="原因五：兼容部分 C 语言字符串函数"></a>原因五：兼容部分 C 语言字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的，但是还是遵循 C 字符串以空字符为结尾的惯例，这些 API 总是将 SDS 保存的数据的尾部设置为空字符，并且总会为 <code>buf</code> 数组分配一个额外的字节空间容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分的 <code>&lt;string.h&gt;</code> 库定义的函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/5c7f5e8b-0a9e-5f63-8236-1b39eddd9caf.png" alt="图片丢失" title="图14"></p>
<p>举个例子，如上图所示，如果我们有一个保存文本数据的 SDS 值的 <code>sds</code>，那么我们有可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数，使用它来对比 SDS 保存字符串和另一个 C 字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf,<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就是不用专门编写一个用来对比 SDS 值和 C 字符串值的函数</p>
<p>类似的我们可以将一个保存了数据的 SDS 作为 <code>strcat</code> 函数的第二个参数，将 SDS 保存的字符串追加到一个 C 字符串的后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(c_string,sds-&gt;buf);</span><br></pre></td></tr></table></figure>
<p>这样 Redis 就不用专门去写一个函数来将 SDS 保存的字符串追加到 C 字符串后面</p>
<p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 `` 函数库， 从而避免了不必要的代码重复</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C 语言字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度的时间复杂度为 <code>O(N)</code></td>
<td style="text-align:center">获取字符串长度的复杂度为<code>O(1)</code></td>
</tr>
<tr>
<td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度 N 次必然需要执行 N 次内存重新分配</td>
<td style="text-align:center">修改字符串 N 次最多需要执行 N 次内存重新分配</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据</td>
<td style="text-align:center">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:center">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数</td>
<td style="text-align:center">可使用部分 <code>&lt;stringh</code> 库中的部分函数</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis字典dict要定义两个哈希表的原因</title>
    <url>/2020/01/22/Redis%E5%AD%97%E5%85%B8dict%E8%A6%81%E5%AE%9A%E4%B9%89%E4%B8%A4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h3 id="Redis-字典-dict-要定义两个哈希表的原因"><a href="#Redis-字典-dict-要定义两个哈希表的原因" class="headerlink" title="Redis 字典 dict 要定义两个哈希表的原因"></a>Redis 字典 dict 要定义两个哈希表的原因</h3><p>Redis 字典 dict 定义两个哈希表是为了给哈希表进行扩展或者收缩准备的</p>
<h3 id="为什么-Redis-字典-dict-中的哈希表要扩展或者收缩"><a href="#为什么-Redis-字典-dict-中的哈希表要扩展或者收缩" class="headerlink" title="为什么 Redis 字典 dict 中的哈希表要扩展或者收缩"></a>为什么 Redis 字典 dict 中的哈希表要扩展或者收缩</h3><p>因为随着操作的不断执行，哈希表保存的键值对的逐渐增加或者减少，为了让哈希表负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对过多或者过少时，程序需要对哈希表的大小执行相应的扩展或者收缩</p>
<h3 id="Redis-字典-dict-如何实现哈希表的扩展和收缩"><a href="#Redis-字典-dict-如何实现哈希表的扩展和收缩" class="headerlink" title="Redis 字典 dict 如何实现哈希表的扩展和收缩"></a>Redis 字典 dict 如何实现哈希表的扩展和收缩</h3><p>扩张和收缩哈希表的工作是通过执行 rehash （重新散列）操作来完成，Redis 对字典 dict 的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作是扩展还是收缩决，以及 ht[0] 包含键值对的数量 （ht[0].used 的值）：<ul>
<li>如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2 ^ n （2 的 n 次方幂）</li>
<li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2 ^ n</li>
</ul>
</li>
<li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表中索引值对应位置上</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建一个空白哈希表，为下一次 rehash 做准备</li>
</ol>
<span id="more"></span>
<p>举个例子，假设程序要对下图所示的字典的 ht[0] 进行扩展操作，那么程序执行以下步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/1abf039c-703b-5fde-b67f-c97fe9e3273b.png" alt="图片丢失" title="图1"></p>
<ol>
<li><p>ht[0].used 当前的值为 4， 4 * 2 = 8 ，而 8 （2 ^ 3） 恰好是第一个大于等于 8 的 2 的 n 次方，所以程序会将 ht[1] 哈希表的大小设置为 8，下图是为 ht[1] 在分配空间之后字典的样子</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/5fbf2db9-21a4-50b7-9dbd-3f78db2da4de.png" alt="图片丢失" title="图2"></p>
</li>
<li><p>将保存在 ht[0] 包含的四个键值对都 rehash 到 ht[1]，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/31ed5ffe-6b5e-5d6d-bfbb-53899e9c5ad9.png" alt="图片丢失" title="图3"></p>
</li>
<li><p>释放 ht[0]，并将 ht[1] 设置为 ht[0]，然后为 ht[1] 分配一个空白的哈希表，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/cb035281-bd11-5778-96e9-c3699b427ea2.png" alt="图片丢失" title="图4"></p>
</li>
</ol>
<p>到此，对哈希表的扩张操作执行完毕，程序成功将哈希表的大小从原来的 4 扩展为 8</p>
<h3 id="哈希表扩展和收缩的触发条件"><a href="#哈希表扩展和收缩的触发条件" class="headerlink" title="哈希表扩展和收缩的触发条件"></a>哈希表扩展和收缩的触发条件</h3><h4 id="哈希表扩展"><a href="#哈希表扩展" class="headerlink" title="哈希表扩展"></a>哈希表扩展</h4><p>当以下条件中的任意一个被满足时，程序和自动开始对哈希表执行扩展</p>
<ol>
<li>服务器目前没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1；</li>
<li>服务器目前正在执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5；</li>
</ol>
<h4 id="哈希表的收缩"><a href="#哈希表的收缩" class="headerlink" title="哈希表的收缩"></a>哈希表的收缩</h4><p>当哈希表的负载因子小于 0.1 时，程序会自动开始对哈希表进行收缩</p>
<p>哈希表的负载因子的计算公式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<p>根据 BGSAVE 命令或者 BGREWRITEAOF 命令是否正在执行，服务器执行执行操作所需的负载因子并不相同，这是因为正在执行 BGSAVE 或者 BGREWRITEAOF 命令的过程中，Redis 需要创建当前服务进程的子进程，而大多数操作系统都采用写时复制技术来优化进程的使用效率，所以子进程存在的期间，服务器会提高执行扩展操作所需要的负载因子，从而尽量地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity中的SecurityContextHolder分析</title>
    <url>/2022/03/31/SpringSecurity%E4%B8%AD%E7%9A%84SecurityContextHolder%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="SpringSecurity-中的-SecurityContextHolder-分析"><a href="#SpringSecurity-中的-SecurityContextHolder-分析" class="headerlink" title="SpringSecurity 中的 SecurityContextHolder 分析"></a>SpringSecurity 中的 SecurityContextHolder 分析</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一般我们在 SpringSecurity 中可以通过 SecurityContextHolder.getContext().getAuthentication()获取到认证信息，这个认证信息就是存放在 SecurityContext 中，这个 SecurityContext 就是通过 SecurityContextHolder.getContext()获取到的，SecurityContextHolder.getContext()的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strategy.getContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面的这个 strategy 是根据具体的策略来确定到底从哪获取 SecurityContext，这个 strategy 的初始化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(strategyName)) &#123;</span><br><span class="line">    <span class="comment">// Set default</span></span><br><span class="line">    <span class="comment">//默认的策略是从ThreadLocal中获取，可以通过在SecurityContextHolder.setStrategyName()方法设置</span></span><br><span class="line">    strategyName = MODE_THREADLOCAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认的策略是从ThreadLocal中获取</span></span><br><span class="line">  <span class="keyword">if</span> (strategyName.equals(MODE_THREADLOCAL)) &#123;</span><br><span class="line">    strategy = <span class="keyword">new</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//可继承的ThreadLocal</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) &#123;</span><br><span class="line">    strategy = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//全局模式</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_GLOBAL)) &#123;</span><br><span class="line">    strategy = <span class="keyword">new</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Try to load a custom strategy</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = Class.forName(strategyName);</span><br><span class="line">      Constructor&lt;?&gt; customStrategy = clazz.getConstructor();</span><br><span class="line">      strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.handleReflectionException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initializeCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal 模式下的使用的是 ThreadLocalSecurityContextHolderStrategy 这个类的对象来存储 SecurityContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line">    <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">  <span class="comment">// ~ Static fields/initializers</span></span><br><span class="line">  <span class="comment">// =====================================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用ThreadLocal来存储，在同一个线程中可以获取得到（不了解ThredLocal的使用可以上网查一下）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ~ Methods</span></span><br><span class="line">  <span class="comment">// ========================================================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">    contextHolder.remove();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SecurityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> contextHolder.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">      ctx = createEmptyContext();</span><br><span class="line">      contextHolder.set(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">    Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">    contextHolder.set(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再看下全局模式对应的 GlobalSecurityContextHolderStrategy 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span> <span class="keyword">implements</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">  <span class="comment">// ~ Static fields/initializers</span></span><br><span class="line">  <span class="comment">// =====================================================================================</span></span><br><span class="line">  <span class="comment">//直接使用静态变量存储，所有线程获取到的都是同一个东西</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SecurityContext contextHolder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ~ Methods</span></span><br><span class="line">  <span class="comment">// ========================================================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">    contextHolder = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (contextHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">      contextHolder = <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contextHolder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">    Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">    contextHolder = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那个可继承 ThreadLocal 用得比较少，应该和和上面的 ThradLocal 差不多，感兴趣的可以去网上查一下，这里就不分析了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>SecurityContextHolder 的作用是保存 SecurityContext</li>
<li>SecurityContextHolder 默认使用的是 ThreadLocal 模式来保存 SecurityContext，在这种模式下同一个线程获取到 SecurityContext 都是一样的，如果是全局模式下，所有的线程获取到的 SecurityContext 都是同一个，如果需要使用其它模式可以通过调用 SecurityContextHolder.setStrategyName 方法来设置</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI机制</title>
    <url>/2021/12/16/SPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>这篇文章大部分都是参考的下面<a href="https://www.cnkirito.moe/spi/">这位大佬的文章</a>，真的很推荐去看下，写得真的很不错。</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>JDK 提供的 SPI(Service Provider Interface)机制，可能很多人不太熟悉，因为这个机制是针对厂商或者插件的，也可以在一些框架的扩展中看到。其核心类 <code>java.util.ServiceLoader</code> 可以在 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">jdk1.8</a> 的文档中看到详细的介绍。虽然不太常见，但并不代表它不常用，恰恰相反，你无时无刻不在用它。玄乎了，莫急，思考一下你的项目中是否有用到第三方日志包，是否有用到数据库驱动？其实这些都和 SPI 有关。再来思考一下，现代的框架是如何加载日志依赖，加载数据库驱动的，你可能会对<code>class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>这段代码不陌生，这是每个 java 初学者必定遇到过的，但如今的数据库驱动仍然是这样加载的吗？你还能找到这段代码吗？这一切的疑问，将在本篇文章结束后得到解答。</p>
<h4 id="实现一个自定义的-SPI"><a href="#实现一个自定义的-SPI" class="headerlink" title="实现一个自定义的 SPI"></a>实现一个自定义的 SPI</h4><h5 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1 项目结构"></a>1 项目结构</h5><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/2d54d0a7-9dc7-496e-82ea-7fd7c948bff5.png" alt="图片丢失" title="SPI项目结构"></p>
<ol>
<li>invoker 是我们的用来测试的主项目。</li>
<li>interface 是针对厂商和插件商定义的接口项目，只提供接口，不提供实现。</li>
<li>good-printer,bad-printer 分别是两个厂商对 interface 的不同实现，所以他们会依赖于 interface 项目。</li>
</ol>
<span id="more"></span>
<p>这个简单的 demo 就是让大家体验，在不改变 invoker 代码，只更改依赖的前提下，切换 interface 的实现厂商。</p>
<h5 id="2-interface-模块"><a href="#2-interface-模块" class="headerlink" title="2 interface 模块"></a>2 interface 模块</h5><h6 id="2-1-top-ouzhanbo-spi-api-Printer"><a href="#2-1-top-ouzhanbo-spi-api-Printer" class="headerlink" title="2.1 top.ouzhanbo.spi.api.Printer"></a>2.1 top.ouzhanbo.spi.api.Printer</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface 只定义一个接口，不提供实现。规范的制定方一般都是比较牛叉的存在，这些接口通常位于 java，javax 前缀的包中。这里的 Printer 就是模拟一个规范接口。</p>
<h5 id="3-good-printer-模块"><a href="#3-good-printer-模块" class="headerlink" title="3 good-printer 模块"></a>3 good-printer 模块</h5><h6 id="3-1-good-printer-pom-xml"><a href="#3-1-good-printer-pom-xml" class="headerlink" title="3.1 good-printer\pom.xml"></a>3.1 good-printer\pom.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.ouzhanbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>printer-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>规范的具体实现类必然要依赖规范接口</p>
<h6 id="3-2-top-ouzhanbo-spi-api-GoodPrinter"><a href="#3-2-top-ouzhanbo-spi-api-GoodPrinter" class="headerlink" title="3.2 top.ouzhanbo.spi.api.GoodPrinter"></a>3.2 top.ouzhanbo.spi.api.GoodPrinter</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodPrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你是个好人 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为 Printer 规范接口的实现一</p>
<h6 id="3-3-resources-META-INF-services-top-ouzhanbo-spi-api-Printer"><a href="#3-3-resources-META-INF-services-top-ouzhanbo-spi-api-Printer" class="headerlink" title="3.3 resources\META-INF\services\top.ouzhanbo.spi.api.Printer"></a>3.3 resources\META-INF\services\top.ouzhanbo.spi.api.Printer</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">top.ouzhanbo.spi.spi.GoodPrinter</span><br></pre></td></tr></table></figure>
<p>这里需要重点说明，每一个 SPI 接口都需要在自己项目的静态资源目录中声明一个 services 文件，文件名为实现规范接口的类名全路径，在此例中便是 <code>top.ouzhanbo.spi.api.Printer</code>，在文件中，则写上一行具体实现类的全路径，在此例中便是 <code>top.ouzhanbo.spi.api.GoodPrinter</code>。</p>
<h5 id="4-bad-printer-模块"><a href="#4-bad-printer-模块" class="headerlink" title="4 bad-printer 模块"></a>4 bad-printer 模块</h5><h6 id="4-1-bad-printer-pom-xml"><a href="#4-1-bad-printer-pom-xml" class="headerlink" title="4.1 bad-printer\pom.xml"></a>4.1 bad-printer\pom.xml</h6><p>我们在按照和 good-printer 模块中定义的一样的方式，完成另一个厂商对 Printer 规范的实现。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.ouzhanbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>printer-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="4-2-top-ouzhanbo-spi-api-BadPrinter"><a href="#4-2-top-ouzhanbo-spi-api-BadPrinter" class="headerlink" title="4.2 top.ouzhanbo.spi.api.BadPrinter"></a>4.2 top.ouzhanbo.spi.api.BadPrinter</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BadPrinter</span> <span class="keyword">implements</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我抽烟，喝酒，蹦迪，但我知道我是好女孩 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-resources-META-INF-services-moe-cnkirito-spi-api-Printer"><a href="#4-3-resources-META-INF-services-moe-cnkirito-spi-api-Printer" class="headerlink" title="4.3 resources\META-INF\services\moe.cnkirito.spi.api.Printer"></a>4.3 resources\META-INF\services\moe.cnkirito.spi.api.Printer</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">top.ouzhanbo.spi.api.BadPrinter</span><br></pre></td></tr></table></figure>
<p>这样，另一个厂商的实现便完成了。</p>
<h5 id="5-invoker-模块"><a href="#5-invoker-模块" class="headerlink" title="5 invoker 模块"></a>5 invoker 模块</h5><h6 id="5-1-invoker-pom-xml"><a href="#5-1-invoker-pom-xml" class="headerlink" title="5.1 invoker\pom.xml"></a>5.1 invoker\pom.xml</h6><p>这里的 invoker 便是我们自己的项目了。如果一开始我们想使用厂商 good-printer 的 Printer 实现，是需要将其的依赖引入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.ouzhanbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>good-printer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="5-2-编写调用主类"><a href="#5-2-编写调用主类" class="headerlink" title="5.2 编写调用主类"></a>5.2 编写调用主类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Printer&gt; printerLoader = ServiceLoader.load(Printer.class);</span><br><span class="line">        <span class="keyword">for</span> (Printer printer : printerLoader) &#123;</span><br><span class="line">            printer.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceLoader 是 <code>java.util</code> 提供的用于加载固定类路径下文件的一个加载器，正是它加载了对应接口声明的实现类。</p>
<h6 id="5-3-打印结果-1"><a href="#5-3-打印结果-1" class="headerlink" title="5.3 打印结果 1"></a>5.3 打印结果 1</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">你是个好人 ~</span><br></pre></td></tr></table></figure>
<h6 id="5-4-更换-invoker-pom-xml-中的-Printer-实现，使用厂商-bad-printer-的-Printer-实现"><a href="#5-4-更换-invoker-pom-xml-中的-Printer-实现，使用厂商-bad-printer-的-Printer-实现" class="headerlink" title="5.4 更换 invoker\pom.xml 中的 Printer 实现，使用厂商 bad-printer 的 Printer 实现"></a>5.4 更换 invoker\pom.xml 中的 Printer 实现，使用厂商 bad-printer 的 Printer 实现</h6><p>如果在后续的方案中，想替换厂商的 Printer 实现，只需要将<code>invoker\pom.xml</code>文件中的依赖更换</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.ouzhanbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bad-printer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="5-5-打印的结果"><a href="#5-5-打印的结果" class="headerlink" title="5.5 打印的结果"></a>5.5 打印的结果</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">我抽烟，喝酒，蹦迪，但我知道我是好女孩 ~</span><br></pre></td></tr></table></figure>
<p>是不是很神奇呢？这一切对于调用者来说都是透明的，只需要切换依赖即可！</p>
<h4 id="SPI-的简单源码分析"><a href="#SPI-的简单源码分析" class="headerlink" title="SPI 的简单源码分析"></a>SPI 的简单源码分析</h4><ol>
<li><p>从 Invoker 上面看应该从 ServiceLoader 的 load 方法进入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//第一步，调用ServiceLoader的load(Class&lt;S&gt; service)</span></span><br><span class="line">        ServiceLoader&lt;Printer&gt; printerLoader = ServiceLoader.load(Printer.class);</span><br><span class="line">        <span class="keyword">for</span> (Printer printer : printerLoader) &#123;</span><br><span class="line">            printer.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ServiceLoader 的调用代码上看，ServiceLoader 是可以迭代的，因为 ServiceLoader 应该实现了 Iterable 接口(这里是个伏笔，后面会 for 循环时会调用实现后的 iterator 方法)</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/ac312ea5-eea9-40c7-8d1b-99bd7b5b6626.jpg" alt="图片丢失" title="ServiceLoader实现了Iterable"></p>
</li>
<li><p>ServiceLoader 的 <code>load(Class&lt;S&gt; service)</code>方法代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">//第二步调用ServiceLoader的load(Class&lt;S&gt; service,ClassLoader loader)方法</span></span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServiceLoader 的 <code>load(Class&lt;S&gt; service,ClassLoader loader)</code>方法代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                        ClassLoader loader)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第三步，调用构造方法创建了一个ServiceLoader</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServiceLoader 的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//第四步，调用ServiceLoader的reload()方法</span></span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServiceLoader 的 reload() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    <span class="comment">//第五步，创建了一个LazyIterator对象</span></span><br><span class="line">    lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LazyIterator 是 ServiceLoader 的一个实现了 Iterator 的内部类，到这里好像还没有看到任何读取文件<code>resources\META-INF\services\moe.cnkirito.spi.api.Printer</code>，并且加载该类和创建一个该类对象的代码</p>
</li>
<li><p>我上面说的伏笔就在这里，真正读取<code>resources\META-INF\services\moe.cnkirito.spi.api.Printer</code>文件并且创建文件中指定的类对应的对象的逻辑都在这个 for 循环时调用 iterator 方法里面，先看下 ServiceLoader 实现的 iterator 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for循环时先调用hasNext判断是否存在下个节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//第一次for循环时 knownProviders.hasNext()为false，因为在前面第五步的时候执行过 providers.clear()</span></span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//所以第一次for循环会执行到执行到这一步，这里的lookupIterator是在第五步创建的LazyIterator对象</span></span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//for循环调用next获取下个节点对象</span></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LazyIterator 的 hasNext 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//因为acc为null所以调用 hasNextService</span></span><br><span class="line">        <span class="keyword">return</span> hasNextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 acc 是在第四步 <code>acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;</code>这段代码初始化的，通过断点调试发现最终 acc 为 null 所以调用直接调用 hasNextService 这个方法，断点调试结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/5b9bc6d0-2dba-4a98-a506-23e6d1cc8fec.jpg" alt="图片丢失" title="第四步调试截图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/2484e347-78fb-404b-94e0-70e8f535da77.jpg" alt="图片丢失" title="LazyIterator 的 hasNext 方法获取到的 acc 为null"></p>
</li>
<li><p>LazyIterator 的 hasNextService 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt;</span><br><span class="line">       <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span></span><br><span class="line">           <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt;</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           Class&lt;S&gt; service;</span><br><span class="line">           ClassLoader loader;</span><br><span class="line">           Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;</span><br><span class="line">           Iterator&lt;String&gt; pending = <span class="literal">null</span>;</span><br><span class="line">           <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">private</span> <span class="title function_">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.service = service;</span><br><span class="line">               <span class="built_in">this</span>.loader = loader;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="comment">//nextName初始值为null</span></span><br><span class="line">               <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//PREFIX的值为META-INF/services/，service 是传入的Printer.class</span></span><br><span class="line">                       <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                       <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                           configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           <span class="comment">//得到的fullName为META-INF/services/top.ouzhanbo.spi.api.Printer</span></span><br><span class="line">                           <span class="comment">//并且将类路径下的META-INF/services/top.ouzhanbo.spi.api.Printer加载进来放入configs</span></span><br><span class="line">                           configs = loader.getResources(fullName);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                       fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//这段代码自己调试一下，会比较清楚</span></span><br><span class="line">               <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                   <span class="comment">//configs.hasMoreElements()这段代码可以自己调试看下</span></span><br><span class="line">                   <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//configs.nextElement()这段代码也可以自己调试看下</span></span><br><span class="line">                   <span class="comment">//调试后发现configs是个CompoundEnumeration对象</span></span><br><span class="line">                   <span class="comment">//并且获取到的是configs.nextElement()获取到的是该对象里面的Enumeration&lt;E&gt;[] enums数组的第二个元素</span></span><br><span class="line">                   <span class="comment">//并且该元素是个URLClassLoader类中匿名实现的一个Enumeration对象</span></span><br><span class="line">                   pending = parse(service, configs.nextElement());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">///META-INF/services/top.ouzhanbo.spi.api.Printer文件中声明的类</span></span><br><span class="line">               <span class="comment">//如果BadPrinter和GoodPrinter都依赖进来会怎么样呢？所以最好自己调试一下上面我说的那段代码就清楚了</span></span><br><span class="line">               nextName = pending.next();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>String fullName = PREFIX + service.getName()</code>执行后的到的 fullName 就是<code>META-INF/services/top.ouzhanbo.spi.api.Printer</code>，并且最终获取到的 nextName 为<code>top.ouzhanbo.spi.api.BadPrinter</code>，并且返回 true，最终 ServiceLoader 的 hasNext 返回 true</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/9d8a03a2-2924-4638-a9a2-f28e540a4aca.jpg" alt="图片丢失" title="configs.nextElement()获取到的是一个URLClassLoader类中匿名实现的一个Enumeration对象"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/98f60b25-0fa6-449f-b1ea-6a8afd80b285.jpg" alt="图片丢失" title="最终的到的nextName就是我们pom中依赖进来并且在resources/META-INF/services/top.ouzhanbo.spi.api.Printer文件中声明的类"></p>
</li>
<li><p>ServiceLoader 的 hasNext 返回 true 后就会执行 ServiceLoader 的 next 方法获取下一个节点的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">        <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">    <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 next 方法的调用和上面的 ServiceLoader 的 hasNext 差不多（这里就不再赘述，可以自己调试看下），最后会进入到 LazyIterator 的 nextService 方法里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里还会调用多一次hasNextService方法，不过因为nextName已经有值，所以直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//nextName在这个例子里面的值是top.ouzhanbo.spi.api.BadPrinter</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">    <span class="comment">//这里将nextName清理是为了多个接口的实现时，hasNextService可以获取到所有的实现类（这里可以留意一下hasNextService里nextName != null）</span></span><br><span class="line">    nextName = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//最终将nextName对应的类加载进来</span></span><br><span class="line">        c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将加载进来的类通过反射创建一个实例并且强制转化为service（这里对应的是top.ouzhanbo.spi.api.Printer.class）这种类型</span></span><br><span class="line">        <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//放入provioders中，下次再for循环就通过上面第六步将其转为knownProviders，就不需要再重复加载和创建</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终将在 pom 中依赖进来并且在<code>resources/META-INF/services/top.ouzhanbo.spi.api.Printer</code>文件中声明的类加载进来并且实例化一个该类的对象并返回给上层，所以通过这种机制可以实现在不改变调用代码的情况下，通过改变依赖来实现通实现的替换</p>
</li>
</ol>
<h4 id="SPI-在实际项目中的应用"><a href="#SPI-在实际项目中的应用" class="headerlink" title="SPI 在实际项目中的应用"></a>SPI 在实际项目中的应用</h4><p>现在大部分的项目都用了 mysql，这个时候就需要在 pom 中引入<code>mysql-connector-java</code>用于数据连接</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>里面就有一个<code>java.sql.Driver</code>的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">    *             if a database error occurs.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并且在该 jar 包下存在<code>META-INF/services/java.sql.Driver</code>这个文件并且文件的内容为这个是这个实现类的全类名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/fee37eef-82ba-40ed-b862-c41c890c3649.jpg" alt="图片丢失" title="mysql-connector-java这个jar包下的META-INF/services/java.sql.Driver"></p>
<p>既然说到了数据库驱动，索性再多说一点，还记得一道经典的面试题：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 到底做了什么事？要想清楚这个问题我们可以先看看<code>com.mysql.jdbc.Driver</code>（这里因为我用的是 mysql8，所以上面<code>META-INF/services/java.sql.Driver</code>里面的内容是<code>com.mysql.cj.jdbc.Driver</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. &quot;</span></span><br><span class="line">                + <span class="string">&quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看好像上面都没有，只打印了两句话，翻译一下大概的意思是</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#x27;com.mysql.jdbc.Driver&#x27;已被弃用。新的驱动类是&#x27;com.mysql.cj.jdbc.Driver&#x27;。该驱动类通过SPI自动注册，一般不需要手动加载驱动类</span><br></pre></td></tr></table></figure>
<p>按照这句话的意思已经不再需要用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载驱动类了，是通过 SPI 加载的，至于这个 SPI 是怎么加载数据库驱动的我们后面再说，先看看<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>这种老方法怎么加载驱动的。</p>
<p>既然在<code>com.mysql.jdbc.Driver</code>这类中没看到想要的东西我们就去他的父类<code>com.mysql.cj.jdbc.Driver</code>中找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在这里创建了一个com.mysql.cj.jdbc.Driver的实例并且通过java.sql.DriverManager将其注册</span></span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的静态代码块里创建了一个<code>`的实例并且通过</code>java.sql.DriverManager<code>将其注册，我们继续往</code>registerDriver(java.sql.Driver driver)<code>这个方法里面深入最后会在</code>java.sql.DriverManager<code>里面的</code>registerDriver(java.sql.Driver driver,DriverAction da)`这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span><br><span class="line"><span class="params">        DriverAction da)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the driver if it has not already been added to our list */</span></span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从代码上看这里如果这个驱动如果不存在就会被加入到registeredDrivers这个列表中</span></span><br><span class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver, da));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;registerDriver: &quot;</span> + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>registeredDrivers 是个 DriverManager 里的一个静态列表，在上面的代码中看出如果这个驱动如果不存在就会被加入到 registeredDrivers 这个列表中</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/0389fc65-a4a2-4b23-9109-715bb0d0c9d1.png" alt="图片丢失" title="registeredDrivers 是个DriverManger里面的一个静态列表"></p>
<p>前面源码里面说了新的驱动类是<code>com.mysql.cj.jdbc.Driver</code>。该驱动类通过 SPI 自动注册，一般不需要手动加载驱动类，那我们来看看<code>com.mysql.cj.jdbc.Driver</code>是如何通过 SPI 加载的，想想我们<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>之后就需要调用<code>Connection connection = DriverManager.getConnection(String url, String user, String password)</code>，所以我们先看下 DriverManager 这个类的代码，发现里面有段静态代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//这个方法是用于加载初始驱动</span></span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadInitialDrivers 这个方法说得很明白，就是加载初始驱动，直接点进去看下这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//jdbc.drivers这个系统属性不是本来系统自带的，需要用户自己通过System.setProperty设定</span></span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">    <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">    <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">    <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SPI就是在这里加载数据库驱动</span></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">             * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">             * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">             * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">             * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">             * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">             * and load the service.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">             * if driver not available in classpath but it&#x27;s</span></span><br><span class="line"><span class="comment">             * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    <span class="comment">//在这个方法里创建加载数据库驱动类并且创建实例</span></span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>最终我们了解了为什么在不使用 Class.forName 的情况下，驱动类是如何通过 SPI 实现自动加载的</p>
<p>说到这里我们来说点无关的，看看<code>Connection connection = DriverManager.getConnection(String url,String user, String password)</code>是怎么获取正确的数据库连接的，进入代码我们最后会发现进入了下面这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">     * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">     * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">     * can be loaded from here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">        <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">        <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">            callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="comment">//遍历registeredDrivers从中一个个取出驱动，然后根据输入的连接信息一个个的尝试创建数据库连接，创建成功就将该连接返回</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码上面有有句注释<code>Walk through the loaded registeredDrivers attempting to make a connection</code>，大致意思是说遍历已加载的已注册驱动程序以尝试建立连接，再结合下面遍历 registeredDrivers 的代码看出该方法是通过遍历 registeredDrivers 从中一个个取出驱动，然后根据输入的连接信息一个个的尝试创建数据库连接，创建成功就将该连接返回</p>
<p>最后看了上面的数据库驱动加载的源码分析就可以把上面的面试题回答了，<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>调用到驱动类里面的静态代码块，在静态代码块里创建了一个驱动类的实例并且通过<code>java.sql.DriverManager</code>将其注册到 <code>java.sql.DriverManager</code> 里面的静态列表 registeredDrivers 中，并且在现在新的数据库驱动已经不再需要通过 Class.forName 加载而是是用 SPI 的机制加载了</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity 源码(一)——SpringSecurity如何被加载进来的？</title>
    <url>/2022/01/28/SpringSecurity%20%E6%BA%90%E7%A0%81(%E4%B8%80)%E2%80%94%E2%80%94SpringSecurity%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%9B%E6%9D%A5%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="SpringSecurity-源码-一-——SpringSecurity-如何被加载进来的？"><a href="#SpringSecurity-源码-一-——SpringSecurity-如何被加载进来的？" class="headerlink" title="SpringSecurity 源码(一)——SpringSecurity 如何被加载进来的？"></a>SpringSecurity 源码(一)——SpringSecurity 如何被加载进来的？</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这篇文章还是参考了<a href="https://www.cnkirito.moe/spring-security-7/">这个大佬的这篇文章</a>，文笔不好，如果觉得难理解可以看大佬的文章</p>
<h4 id="xml-的方式配置-SpringSecurity"><a href="#xml-的方式配置-SpringSecurity" class="headerlink" title="xml 的方式配置 SpringSecurity"></a>xml 的方式配置 SpringSecurity</h4><p>在 web.xml 中添加 filter 的相关配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  //这里的filter-name必须是springSecurityFilterChain，这里先记住后面源码分析的时候可以知道为什么一定要叫这个名字</span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面在 web.xml 中声明了 DelegatingFilterProxy 这个 filter 并且在 url-pattern 中以 /*让它拦截所以的请求，那么在我们第一次请求的时候就调用 DelegatingFilterProxy 的 init 方法，阅读源码发现调用逻辑简单总结如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/747a461a-9ae9-4056-9a9c-343d0d6dd07f.png" alt="图片丢失" title="DelegatingFilterProxy的init方法的调用逻辑"></p>
<p>可以看到在 DelegatingFilterProxy 的 initFilterBean()方法中调用了 AbstractApplicationContext 的 getBean(String name, Class&lt; T &gt; requiredType)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">targetBeanName</span> <span class="operator">=</span> getTargetBeanName();</span><br><span class="line">  Assert.state(targetBeanName != <span class="literal">null</span>, <span class="string">&quot;No target bean name set&quot;</span>);</span><br><span class="line">  <span class="comment">//这里的targetBeanName就是我们上面再web.xml中设置的springSecurityFilterChain</span></span><br><span class="line">  <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> wac.getBean(targetBeanName, Filter.class);</span><br><span class="line">  <span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">    delegate.init(getFilterConfig());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 targetBeanName 的值是在上层的 DelegatingFilterProxy 的 initFilterBean()方法中设置的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.targetBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//默认是null，所以在getFilterName()方法中获取</span></span><br><span class="line">        <span class="built_in">this</span>.targetBeanName = getFilterName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">      <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = initDelegate(wac);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getFilterName()方法的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getFilterName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//这里通过this.filterConfig.getFilterName()获取到的就是我在web.xml的filter-name中设置的springSecurityFilterChain</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">this</span>.filterConfig != <span class="literal">null</span> ? <span class="built_in">this</span>.filterConfig.getFilterName() : <span class="built_in">this</span>.beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这个名字叫 springSecurityFilterChain 的 bean 到底是哪个类的实例，从 getBean 方法一路深入，调用逻辑如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/04695e3b-cb02-49c3-9991-5f27343453a2.png" alt="图片丢失" title="getBean的调用逻辑"></p>
<p>在 AbstractBeanFactory 的 doGetBean(String name, @Nullable Class&lt; T &gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">    <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这里将名字springSecurityFilterChain转化为Spring认为的规范名字</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">  Object beanInstance;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">  <span class="comment">//省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>打个断点调试会发现在 AbstractBeanFactory 的 canonicalName(String name)方法中获取到了这个所谓的规范名字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">canonicalName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> name;</span><br><span class="line"></span><br><span class="line">  String resolvedName;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//在这个aliasMap里面存放着springSecurityFilterChain的规范名字</span></span><br><span class="line">    resolvedName = <span class="built_in">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedName != <span class="literal">null</span>) &#123;</span><br><span class="line">      canonicalName = resolvedName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (resolvedName != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试的截图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/e9acea22-3cf7-4535-95ea-8e5e210e05e4.jpg" alt="图片丢失" title="springSecurityFilterChain的规范名字的获取"></p>
<p>所以这个 springSecurityFilterChain 对应的规范名字就是 org.springframework.security.filterChainProxy</p>
<p>那这个 aliasMap 中的 springSecurityFilterChain 的键值对数据是在哪被保存进来的呢？经过断点调试发现是在 HttpSecurityBeanDefinitionParser 中的 registerFilterChainProxyIfNecessary(ParserContext pc, Object source) 方法将这个键值对保存进 aliasMap 中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerFilterChainProxyIfNecessary</span><span class="params">(ParserContext pc, Object source)</span> &#123;</span><br><span class="line">  <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> pc.getRegistry();</span><br><span class="line">  <span class="keyword">if</span> (registry.containsBeanDefinition(BeanIds.FILTER_CHAIN_PROXY)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个ListFactoryBean的BeanDefinition（ListFactoryBean是FactoryBean的子类，在我们通过Spring容器获FactoryBean的实例并不是它本身而是它的getObject方法返回的对象，具体关于FactoryBean的知识可以自己了解一下，这里不扩展)</span></span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">listFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ListFactoryBean.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在spring创建完ListFactoryBean这个bean后会将new ManagedList()创建的这个列表赋值给bean里面的sourceList这个属性赋</span></span><br><span class="line">  listFactoryBean.getPropertyValues().add(<span class="string">&quot;sourceList&quot;</span>, <span class="keyword">new</span> <span class="title class_">ManagedList</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这段代码内部将ListFactoryBean这个BeanDefinition以BeanIds.FILTER_CHAINS的名字注册到spring中，之后在初始化bean的时候就会将ListFactoryBean这个实例创建并且放入spring中管理</span></span><br><span class="line">  pc.registerBeanComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(listFactoryBean, BeanIds.FILTER_CHAINS));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这里创建了FilterChainProxy的BeanDefinitionBuilder，在这个BeanDefinitionBuilder里面就包含了一个BeanDefinition</span></span><br><span class="line">  <span class="type">BeanDefinitionBuilder</span> <span class="variable">fcpBldr</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(FilterChainProxy.class);</span><br><span class="line">  fcpBldr.getRawBeanDefinition().setSource(source);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里说明在后面spring初始化FilterChainProxy这个实例时构造器需要一个名字叫BeanIds.FILTER_CHAINS的实例</span></span><br><span class="line">  fcpBldr.addConstructorArgReference(BeanIds.FILTER_CHAINS);</span><br><span class="line"></span><br><span class="line">  fcpBldr.addPropertyValue(<span class="string">&quot;filterChainValidator&quot;</span>, <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultFilterChainValidator.class));</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">fcpBean</span> <span class="operator">=</span> fcpBldr.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这段代码内部将FilterChainProxy这个BeanDefinition以BeanIds.FILTER_CHAIN_PROXY的名字注册到spring中，之后在初始化bean的时候就会将FilterChainProxy这个实例创建并且放入spring中管理</span></span><br><span class="line">  pc.registerBeanComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(fcpBean, BeanIds.FILTER_CHAIN_PROXY));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的BeanIds.SPRING_SECURITY_FILTER_CHAIN和BeanIds.FILTER_CHAIN_PROXY分别就是我们上面的键springSecurityFilterChain和值org.springframework.security.filterChainProxy</span></span><br><span class="line">  registry.registerAlias(BeanIds.FILTER_CHAIN_PROXY, BeanIds.SPRING_SECURITY_FILTER_CHAIN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeaIds 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BeanIds</span> &#123;</span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.security.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FILTER_CHAIN</span> <span class="operator">=</span> <span class="string">&quot;springSecurityFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_CHAIN_PROXY</span> <span class="operator">=</span> PREFIX + <span class="string">&quot;filterChainProxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_CHAINS</span> <span class="operator">=</span> PREFIX + <span class="string">&quot;filterChains&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的源码分析我们知道了这个 springSecurityFilterChain 名字对应的 bean 就是 FilterChainProxy 这个类的实例，springSecurityFilterChain 只不过是这个 bean 的别名，它的规范名字是 org.springframework.security.filterChainProxy</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/18a7e740-cfec-4142-9775-f860ecb5941e.jpg" alt="图片丢失" title="AbstractBeanFactory的doGetBean方法的调试截图"></p>
<p>从调试结果上看，springSecurityFilterChain 这个 bean 确实是 org.springframework.security.FilterChainProxy 这个类的实例</p>
<p>再回来看看 DelegatingFilterProxy 的 doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">  <span class="comment">//用了双if判断的方式保证delegate只被实例化一次（不了解双if判断的作用的话可以了解一下单例模式的双if判断），因为initDelegate方法中已经对delegate初始化过了，所以if里面的逻辑不会执行，只是多提一嘴</span></span><br><span class="line">  <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">      delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">      <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">              <span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        delegateToUse = initDelegate(wac);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里才是需要关心的入口</span></span><br><span class="line">  invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 DelegatingFilterProxy 的 invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)方法的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">    Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">  <span class="comment">//从这里看到真正调用的是FilterChainProxy的doFilter方法</span></span><br><span class="line">  delegate.doFilter(request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下 FilterChainProxy 的 doFilter(ServletRequest request, ServletResponse response, FilterChain chain)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">clearContext</span> <span class="operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!clearContext) &#123;</span><br><span class="line">    doFilterInternal(request, response, chain);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    <span class="comment">//在这里调用了真正的过滤逻辑</span></span><br><span class="line">    doFilterInternal(request, response, chain);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RequestRejectedException ex) &#123;</span><br><span class="line">    <span class="built_in">this</span>.requestRejectedHandler.handle((HttpServletRequest) request, (HttpServletResponse) response, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">    request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterChainProxy 的 doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)方法的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">  <span class="type">FirewalledRequest</span> <span class="variable">firewallRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.firewall.getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">  <span class="type">HttpServletResponse</span> <span class="variable">firewallResponse</span> <span class="operator">=</span> <span class="built_in">this</span>.firewall.getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">  List&lt;Filter&gt; filters = getFilters(firewallRequest);</span><br><span class="line">  <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(LogMessage.of(() -&gt; <span class="string">&quot;No security for &quot;</span> + requestLine(firewallRequest)));</span><br><span class="line">    &#125;</span><br><span class="line">    firewallRequest.reset();</span><br><span class="line">    chain.doFilter(firewallRequest, firewallResponse);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(LogMessage.of(() -&gt; <span class="string">&quot;Securing &quot;</span> + requestLine(firewallRequest)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建了一条虚拟的过滤器链，然后调用这条过滤器链里的过滤逻辑，filters就是这条过滤器链中的过滤器</span></span><br><span class="line">  <span class="type">VirtualFilterChain</span> <span class="variable">virtualFilterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(firewallRequest, chain, filters);</span><br><span class="line">  virtualFilterChain.doFilter(firewallRequest, firewallResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterChainProxy 的部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取到匹配的SecurityFilterChain实例，并且获取并且返回这个过滤器链中的过滤器</span></span><br><span class="line">    <span class="keyword">for</span> (SecurityFilterChain chain : <span class="built_in">this</span>.filterChains) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(LogMessage.format(<span class="string">&quot;Trying to match request against %s (%d/%d)&quot;</span>, chain, ++count,</span><br><span class="line">            <span class="built_in">this</span>.filterChains.size()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> chain.getFilters();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下 filterChains 只有一个实例，并且这个实例有 10 个默认的过滤器</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/39127ee4-a139-4141-b552-3f131daf810b.jpg" alt="图片丢失" title="getFilters方法调试截图"></p>
<p>下面的代码解析会涉及到一些 spring 的加载原理，如果觉得有点晕的话可以先不要看，等简单学过 spring 源码再看也可以。</p>
<p>问题来了，这里的默认的过滤器链和里面的过滤器在哪定义的？我们先看下 HttpSecurityBeanDefinitionParser 的 parse(Element element, ParserContext pc)方法的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext pc)</span> &#123;</span><br><span class="line">  <span class="type">CompositeComponentDefinition</span> <span class="variable">compositeDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeComponentDefinition</span>(element.getTagName(),</span><br><span class="line">      pc.extractSource(element));</span><br><span class="line">  pc.pushContainingComponent(compositeDef);</span><br><span class="line">  <span class="comment">//我们上面看过源码的方法</span></span><br><span class="line">  registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));</span><br><span class="line">  <span class="comment">// Obtain the filter chains and add the new chain to it</span></span><br><span class="line">  <span class="comment">//上面的源码的注释已经说得很清楚了，下面的逻辑就是获取过滤器链列表并且向里面添加一个新的过滤器链，这个名叫BeanIds.FILTER_CHAINS的BeanDefinition不就是前面在registerFilterChainProxyIfNecessary方法里面我们注册到spring中的吗，当时还给它里面的sourceList指定了一个初始列表，不记得可以看会上面的registerFilterChainProxyIfNecessary方法</span></span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">listFactoryBean</span> <span class="operator">=</span> pc.getRegistry().getBeanDefinition(BeanIds.FILTER_CHAINS);</span><br><span class="line">  <span class="comment">//获取listFactoryBean中的sourceList，sourceList指向一个空的列表</span></span><br><span class="line">  List&lt;BeanReference&gt; filterChains = (List&lt;BeanReference&gt;) listFactoryBean.getPropertyValues()</span><br><span class="line">      .getPropertyValue(<span class="string">&quot;sourceList&quot;</span>).getValue();</span><br><span class="line">  <span class="comment">//向这个列表里面添加一个过滤器链</span></span><br><span class="line">  filterChains.add(createFilterChain(element, pc));</span><br><span class="line">  pc.popAndRegisterContainingComponent();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面的代码我们应该可以猜测到这些这个过滤器链里面的过滤器应该就在 createFilterChain 这个方法里面放进去的，那就继续深入 createFilterChain 这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanReference <span class="title function_">createFilterChain</span><span class="params">(Element element, ParserContext pc)</span> &#123;</span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//这些filter的定义就是在下面两段代码和buildCustomFilterList这个方法里面创建的（里面的逻辑很复杂，我自己都没看懂，所以先自己看下，以后有机会再分析）</span></span><br><span class="line">  <span class="type">HttpConfigurationBuilder</span> <span class="variable">httpBldr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpConfigurationBuilder</span>(element, forceAutoConfig, pc, portMapper,</span><br><span class="line">      portResolver, authenticationManager);</span><br><span class="line">  <span class="type">AuthenticationConfigBuilder</span> <span class="variable">authBldr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationConfigBuilder</span>(element, forceAutoConfig, pc,</span><br><span class="line">      httpBldr.getSessionCreationPolicy(), httpBldr.getRequestCache(), authenticationManager,</span><br><span class="line">      httpBldr.getSessionStrategy(), portMapper, portResolver, httpBldr.getCsrfLogoutHandler());</span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//将这些filter的定义保存到unorderedFilterChain中</span></span><br><span class="line">  List&lt;OrderDecorator&gt; unorderedFilterChain = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  unorderedFilterChain.addAll(httpBldr.getFilters());</span><br><span class="line">  unorderedFilterChain.addAll(authBldr.getFilters());</span><br><span class="line">  unorderedFilterChain.addAll(buildCustomFilterList(element, pc));</span><br><span class="line">  unorderedFilterChain.sort(<span class="keyword">new</span> <span class="title class_">OrderComparator</span>());</span><br><span class="line">  checkFilterChainOrder(unorderedFilterChain, pc, pc.extractSource(element));</span><br><span class="line">  <span class="comment">// The list of filter beans</span></span><br><span class="line">  List&lt;BeanMetadataElement&gt; filterChain = <span class="keyword">new</span> <span class="title class_">ManagedList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//遍历unorderedFilterChain将这些filter的定义放入filterChain中，最终以参数传入createSecurityFilterChainBean这个方法中，并且再这个方法中创建这条过滤器链的bean引用</span></span><br><span class="line">  <span class="keyword">for</span> (OrderDecorator od : unorderedFilterChain) &#123;</span><br><span class="line">    filterChain.add(od.bean);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createSecurityFilterChainBean(element, pc, filterChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看下 createSecurityFilterChainBean(Element element, ParserContext pc, List&lt;?&gt; filterChain)方法的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanReference <span class="title function_">createSecurityFilterChainBean</span><span class="params">(Element element, ParserContext pc, List&lt;?&gt; filterChain)</span> &#123;</span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//创建一个DefaultSecurityFilterChain的BeanDefinition</span></span><br><span class="line">  <span class="type">BeanDefinitionBuilder</span> <span class="variable">filterChainBldr</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">      .rootBeanDefinition(DefaultSecurityFilterChain.class);</span><br><span class="line">  filterChainBldr.addConstructorArgValue(filterChainMatcher);</span><br><span class="line">  <span class="comment">//为这个BeanDefinition加入之后创建时需要用到过滤器定义列表（就是我们上面创建那堆filter的定义）</span></span><br><span class="line">  filterChainBldr.addConstructorArgValue(filterChain);</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">filterChainBean</span> <span class="operator">=</span> filterChainBldr.getBeanDefinition();</span><br><span class="line">  <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">    id = element.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">      id = pc.getReaderContext().generateBeanName(filterChainBean);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将这个DefaultSecurityFilterChain的BeanDefinition注册到spring容器中</span></span><br><span class="line">  pc.registerBeanComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(filterChainBean, id));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法最终会返回一个 BeanReference，这个 BeanReference 里面就有这个过滤器链在 spring 容器中的名字，到时只需要 spring 只需要根据这个名字找到创建后的过滤器链实例即可</p>
<p>上面的分析是不是很晕，因为这说的过滤器和过滤器链都不是真正的实例，因为这个时候 spring 还没开始创建实例只是在处理 bean 之间的引用关系，所以才会有 BeanDefinition 和 BeanReference 和其他乱七八糟的东西，不过只要简单了解 spring 的启动原理其实是不难理解的（没办法啊，涉及到 spring 东西基本的加载都和 spring 的原理有关），所以如果看不懂的话可以先去了解一下 spring 原理（不需要很深入的了解，只需要知道为什么会有 BeanDefinition 和 BeanReference 和其他杂七杂八的东西就行，因为我也只是简单的看过一点，所以写得不好请不要见怪）</p>
<h4 id="servlet3-0-环境下-java-Config-配置-SpringSecurity"><a href="#servlet3-0-环境下-java-Config-配置-SpringSecurity" class="headerlink" title="servlet3.0+ 环境下 java Config 配置 SpringSecurity"></a>servlet3.0+ 环境下 java Config 配置 SpringSecurity</h4><p>自定义一个 SecurityWebApplicationInitializer 并且让其继承自 AbstractSecurityWebApplicationInitializer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityWebApplicationInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebApplicationInitializer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring 相关的配置类上加上@EnableWebSecurity 这个注解，我这里的 Spring 相关的配置类是 MyConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;top.ouzhanbo.webspring&quot;,includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Service.class&#125;)&#125;,useDefaultFilters = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简单分析一下一个简单的继承和一个注解就怎么就将 SpringSecurity 加载进来</p>
<p>先看下 AbstractSecurityWebApplicationInitializer 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSecurityWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_CONTEXT_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_FILTER_NAME</span> <span class="operator">=</span> <span class="string">&quot;springSecurityFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">    beforeSpringSecurityFilterChain(servletContext);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.configurationClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">rootAppContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">      rootAppContext.register(<span class="built_in">this</span>.configurationClasses);</span><br><span class="line">      servletContext.addListener(<span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(rootAppContext));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (enableHttpSessionEventPublisher()) &#123;</span><br><span class="line">      servletContext.addListener(<span class="string">&quot;org.springframework.security.web.session.HttpSessionEventPublisher&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    servletContext.setSessionTrackingModes(getSessionTrackingModes());</span><br><span class="line">    insertSpringSecurityFilterChain(servletContext);</span><br><span class="line">    afterSpringSecurityFilterChain(servletContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSpringSecurityFilterChain</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> DEFAULT_FILTER_NAME;</span><br><span class="line">    <span class="comment">//在这里创建了DelegatingFilterProxy这个关键过滤器的实例，并且这个filter的名字就是springSecurityFilterChain</span></span><br><span class="line">    <span class="type">DelegatingFilterProxy</span> <span class="variable">springSecurityFilterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxy</span>(filterName);</span><br><span class="line">    <span class="type">String</span> <span class="variable">contextAttribute</span> <span class="operator">=</span> getWebApplicationContextAttribute();</span><br><span class="line">    <span class="keyword">if</span> (contextAttribute != <span class="literal">null</span>) &#123;</span><br><span class="line">      springSecurityFilterChain.setContextAttribute(contextAttribute);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并且在下面这个方法里将这个DelegatingFilterProxyfilter的实例注册到servletContext中</span></span><br><span class="line">    registerFilter(servletContext, <span class="literal">true</span>, filterName, springSecurityFilterChain);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerFilter</span><span class="params">(ServletContext servletContext, <span class="type">boolean</span> insertBeforeOtherFilters, String filterName,</span></span><br><span class="line"><span class="params">      Filter filter)</span> &#123;</span><br><span class="line">    <span class="comment">//将这个DelegatingFilterProxyfilter的实例注册到servletContext中</span></span><br><span class="line">    <span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addFilter(filterName, filter);</span><br><span class="line">    Assert.state(registration != <span class="literal">null</span>, () -&gt; <span class="string">&quot;Duplicate Filter registration for &#x27;&quot;</span> + filterName</span><br><span class="line">        + <span class="string">&quot;&#x27;. Check to ensure the Filter is only configured once.&quot;</span>);</span><br><span class="line">    registration.setAsyncSupported(isAsyncSecuritySupported());</span><br><span class="line">    EnumSet&lt;DispatcherType&gt; dispatcherTypes = getSecurityDispatcherTypes();</span><br><span class="line">    registration.addMappingForUrlPatterns(dispatcherTypes, !insertBeforeOtherFilters, <span class="string">&quot;/*&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这种使用 javaConfig 的方式相对于使用 xml 的方式跟容易理解，这代码逻辑和 web.xml 上面配置 filter 的效果是完全一样的，这种使用 SCI 的方法我在之前<a href="https://ouzhanbo.top/2022/01/21/Javaweb%E4%BB%8Eweb.xml%20%E5%88%B0%20springboot/">这篇文章里面讲过</a></p>
<p>前面讲过在 DelegatingFilterProxy 的这个 filter 的初始化中会调用到 initFilterBean()方法并在该方法中调用了 AbstractApplicationContext 的 getBean(String name, Class&lt; T &gt; requiredType)方法，并且这里的 targetBeanName 就是 springSecurityFilterChain，我之前分析过，这里也差不多，我就不再说一遍了，可以自己看下源码，相对于 xml 的方式，javaConfig 的配置方式理解起来已经很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">targetBeanName</span> <span class="operator">=</span> getTargetBeanName();</span><br><span class="line">  Assert.state(targetBeanName != <span class="literal">null</span>, <span class="string">&quot;No target bean name set&quot;</span>);</span><br><span class="line">  <span class="comment">//这里的targetBeanName就是我们上面再web.xml中设置的springSecurityFilterChain</span></span><br><span class="line">  <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> wac.getBean(targetBeanName, Filter.class);</span><br><span class="line">  <span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">    delegate.init(getFilterConfig());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了上面的名字叫 springSecurityFilterChain 这个 bean 在哪被注册到 Spring 容器中的？其实也不难猜到是@EnableWebSecurity 这个注解在搞鬼，看下这个注解的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//这面主要看的是WebSecurityConfiguration这个类</span></span><br><span class="line"><span class="meta">@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,</span></span><br><span class="line"><span class="meta">    HttpSecurityConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">debug</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>WebSecurityConfiguration 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span>, BeanClassLoaderAware &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//这里这个Bean的名字就是springSecurityFilterChain（上面的代码提到过）</span></span><br><span class="line">  <span class="meta">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class="line">  <span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> <span class="built_in">this</span>.webSecurityConfigurers != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.webSecurityConfigurers.isEmpty();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasFilterChain</span> <span class="operator">=</span> !<span class="built_in">this</span>.securityFilterChains.isEmpty();</span><br><span class="line">    Assert.state(!(hasConfigurers &amp;&amp; hasFilterChain),</span><br><span class="line">        <span class="string">&quot;Found WebSecurityConfigurerAdapter as well as SecurityFilterChain. Please select just one.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hasConfigurers &amp;&amp; !hasFilterChain) &#123;</span><br><span class="line">      <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.objectObjectPostProcessor</span><br><span class="line">          .postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">          &#125;);</span><br><span class="line">      <span class="built_in">this</span>.webSecurity.apply(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SecurityFilterChain securityFilterChain : <span class="built_in">this</span>.securityFilterChains) &#123;</span><br><span class="line">      <span class="built_in">this</span>.webSecurity.addSecurityFilterChainBuilder(() -&gt; securityFilterChain);</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : securityFilterChain.getFilters()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> FilterSecurityInterceptor) &#123;</span><br><span class="line">          <span class="built_in">this</span>.webSecurity.securityInterceptor((FilterSecurityInterceptor) filter);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (WebSecurityCustomizer customizer : <span class="built_in">this</span>.webSecurityCustomizers) &#123;</span><br><span class="line">      customizer.customize(<span class="built_in">this</span>.webSecurity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.webSecurity.build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//此处省略一万行代码</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想知道 webSecurity.build()返回的是那个类的实例那就从这个 build 方法一路深入，这里就那么啰嗦一个个代码贴出来了，直接给个流程图</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/e3a7999c-14ce-41a8-90ba-92c44567ce11.png" alt="图片丢失" title="webSecurity.build()的调用逻辑"></p>
<p>看下 WebSecurity 的 performBuild()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  Assert.state(!<span class="built_in">this</span>.securityFilterChainBuilders.isEmpty(),</span><br><span class="line">      () -&gt; <span class="string">&quot;At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. &quot;</span></span><br><span class="line">          + <span class="string">&quot;Typically this is done by exposing a SecurityFilterChain bean &quot;</span></span><br><span class="line">          + <span class="string">&quot;or by adding a @Configuration that extends WebSecurityConfigurerAdapter. &quot;</span></span><br><span class="line">          + <span class="string">&quot;More advanced users can invoke &quot;</span> + WebSecurity.class.getSimpleName()</span><br><span class="line">          + <span class="string">&quot;.addSecurityFilterChainBuilder directly&quot;</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> <span class="built_in">this</span>.ignoredRequests.size() + <span class="built_in">this</span>.securityFilterChainBuilders.size();</span><br><span class="line">  List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(chainSize);</span><br><span class="line">  <span class="keyword">for</span> (RequestMatcher ignoredRequest : <span class="built_in">this</span>.ignoredRequests) &#123;</span><br><span class="line">    securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : <span class="built_in">this</span>.securityFilterChainBuilders) &#123;</span><br><span class="line">    securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建FilterChainProxy这个实例，并且将过滤器链列表以构造参数的形式传入（上面securityFilterChains的创建我之后的文章再分析）</span></span><br><span class="line">  <span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.httpFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">    filterChainProxy.setFirewall(<span class="built_in">this</span>.httpFirewall);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.requestRejectedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">    filterChainProxy.setRequestRejectedHandler(<span class="built_in">this</span>.requestRejectedHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">  <span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.debugEnabled) &#123;</span><br><span class="line">    logger.warn(<span class="string">&quot;\n\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;********************************************************************\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;**********        Security debugging is enabled.       *************\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;**********    This may include sensitive information.  *************\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;**********      Do not use in a production system!     *************\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;********************************************************************\n\n&quot;</span>);</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">DebugFilter</span>(filterChainProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.postBuildAction.run();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringBoot-配置-SpringSecurity"><a href="#SpringBoot-配置-SpringSecurity" class="headerlink" title="SpringBoot 配置 SpringSecurity"></a>SpringBoot 配置 SpringSecurity</h4><p>只需要在启动类上加上@EnableWebSecurity 这个注解就可以了（其实可以不加，在 WebSecurityEnablerConfiguration 这个类中引入了这个注解，而 WebSecurityEnablerConfiguration 这个类又被 SecurityAutoConfiguration 这个类通过@Import 注解引入，而 SecurityAutoConfiguration 这个类又会被 SpringBoot 自动装配进来）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootSpringSecurityDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(SpringbootSpringSecurityDemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 SpringBoot 是如何将 DelegatingFilterProxy 这个 filter 加载到 servlet 容器中的？其实还是用到了 SpringBoot 的自动装配，看下 SecurityFilterAutoConfiguration 这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SecurityProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; AbstractSecurityWebApplicationInitializer.class, SessionCreationPolicy.class &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(SecurityAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityFilterAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_FILTER_NAME</span> <span class="operator">=</span> AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnBean(name = DEFAULT_FILTER_NAME)</span></span><br><span class="line">  <span class="keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="title function_">securityFilterChainRegistration</span><span class="params">(</span></span><br><span class="line"><span class="params">      SecurityProperties securityProperties)</span> &#123;</span><br><span class="line">    <span class="type">DelegatingFilterProxyRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxyRegistrationBean</span>(</span><br><span class="line">        DEFAULT_FILTER_NAME);</span><br><span class="line">    registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">    registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> EnumSet&lt;DispatcherType&gt; <span class="title function_">getDispatcherTypes</span><span class="params">(SecurityProperties securityProperties)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (securityProperties.getFilter().getDispatcherTypes() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> securityProperties.getFilter().getDispatcherTypes().stream()</span><br><span class="line">        .map((type) -&gt; DispatcherType.valueOf(type.name()))</span><br><span class="line">        .collect(Collectors.toCollection(() -&gt; EnumSet.noneOf(DispatcherType.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看过<a href="https://ouzhanbo.top/2022/01/21/Javaweb%E4%BB%8Eweb.xml%20%E5%88%B0%20springboot/">这篇文章</a>的话应该就能知道 SpringBoot 在启动的过程中会获取上面的 DelegatingFilterProxyRegistrationBean 这个 Bean 并且调用它的 onStartup 方法，在它的 onStartup 方法一路深入，调用逻辑如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/ca23c272-68ee-4cd5-b9a5-578a68b3326c.png" alt="图片丢失" title="DelegatingFilterProxyRegistrationBean的onStartup调用逻辑"></p>
<p>AbstractFilterRegistrationBean 的 addRegistration 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Dynamic <span class="title function_">addRegistration</span><span class="params">(String description, ServletContext servletContext)</span> &#123;</span><br><span class="line">  <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> getFilter();</span><br><span class="line">  <span class="comment">// 这里getOrDeduceName这个获取到的名字就是上面的DEFAULT_FILTER_NAME（springSecurityFilterChain）</span></span><br><span class="line">  <span class="keyword">return</span> servletContext.addFilter(getOrDeduceName(filter), filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelegatingFilterProxyRegistrationBean 的 getFilter 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DelegatingFilterProxy <span class="title function_">getFilter</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxy</span>(<span class="built_in">this</span>.targetBeanName, getWebApplicationContext()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了延迟初始化DelegatingFilterProxy这个filter，在第一次调用的时候再初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="comment">// Don&#x27;t initialize filter bean on init()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterChainProxy 的创建和初始化和上面说得都差不多，只是 DelegatingFilterProxy 是延迟初始化，看下 DelegatingFilterProxy 的 doFilter 方法就知道了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">  <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">  <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">      delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">      <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">              <span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        delegateToUse = initDelegate(wac);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Let the delegate perform the actual doFilter operation.</span></span><br><span class="line">  invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的英文注解以说的很清楚了，如果在 initFilterBean 方法中没有初始化就会在第一次调用 filter 的时候初始化</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总体来说除了 xml 的那种方式的源码阅读起来是比较难懂的，其实使用 java Config 和 SpringBoot 的方式配置 SpringSecurity 的逻辑还是很好理解的。这篇文章还，文笔不好，如果觉得难理解看<a href="https://www.cnkirito.moe/spring-security-7/">这个大佬的这篇文章</a>，讲得真的不错，推荐！！！</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 三级缓存</title>
    <url>/2024/01/21/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>测试代码如下：</p>
<p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">configurableApplicationContext</span> <span class="operator">=</span> SpringApplication.run(TradeApplication.class, args);</span><br><span class="line">        configurableApplicationContext.getBean(<span class="string">&quot;testClassA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestClassA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassA</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>TestClassB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TestClassA testClassA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里都加上 <code>@Lazy</code>的原因是 springboot 原本启动时还会加载其他的内部的 bean，为了更好的测试分析，让 TestClassA 和 TestClassB 延迟加载，再通过 getBean 方法在第一次获取 TestClassA 对应的 bean 的时候再加载</p>
<p>通过 <code>configurableApplicationContext.getBean(&quot;testClassA&quot;)</code>的 getBean 一路调试进去，会来到 <code>AbstractBeanFactory.doGetBean</code> 这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">    <span class="comment">/**主要关注点 1**/</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">/**主要关注点 2**/</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/**主要关注点 3**/</span></span><br><span class="line">                    <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从关注点 1 <code>Object sharedInstance = getSingleton(beanName)</code> 进入到 <code>DefaultSingletonBeanRegistry.getSingleton</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//第二个参数allowEarlyReference传入true</span></span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                            singletonObject = singletonFactory.getObject();</span><br><span class="line">                            <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                            <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultSingletonBeanRegistry.isSingletonCurrentlyInCreation</code>的逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断一级缓存中是否存在该 bean，如果存在直接返回，如果不存在走第 2 步</li>
<li>判断二级缓存中是否存在该 bean 并且<code>isSingletonCurrentlyInCreation(beanName)</code>返回是否为 true（判断当前 bean 是否正在被创建），不满足条件返回 null</li>
</ol>
<p>但是因为<code>testClassA</code>这个 bean 现在还没被创建，并且<code>isSingletonCurrentlyInCreation(beanName)</code>这个方法返回的是 false（为什么是 false 后面会提到），所以直接返回 null</p>
<p>因为上面找不到所以会跑到关注点 2，这里也是调用 <code>DefaultSingletonBeanRegistry.getSingleton</code>方法，但是实现的逻辑和上面的不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//先从一级缓存获取bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**主要关注点 4**/</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**主要关注点 5**/</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">/**主要关注点 6**/</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">/**主要关注点 7**/</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code> 逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeSingletonCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要关注点 4 中的逻辑主要是将 beanName 加入到 singletonsCurrentlyInCreation 中（singletonsCurrentlyInCreation 是个 Set 集合，只有不存在的时候才可以将 beanName 添加进去），而 singletonsCurrentlyInCreation 就在前面 <code>DefaultSingletonBeanRegistry.isSingletonCurrentlyInCreation</code> 被用到，所以前面为什么返回的 false</p>
<p>前面还有<code>this.inCreationCheckExclusions.contains(beanName)</code>这个判断，从名字能猜到 inCreationCheckExclusions 里面存放的是那些不需要被检查是否正在创建中的 beanName，如果不需要被检查就不需要添加到 singletonsCurrentlyInCreation 中</p>
<p>关注点 5 <code>singletonFactory.getObject()</code>是个 lambda 表达式，真正的逻辑其实就是关注点 3 中的<code>createBean(beanName, mbd, args)</code>，最终会调用到 <code>AbstractAutowireCapableBeanFactory.doCreateBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="comment">/**关注点 8**/</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">/**关注点 9**/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="comment">/**主要关注点 10**/</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">/**关注点 11**/</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注点 8 主要是对实例化一个 bean，没什么好说的，关注点 9 判断的就是 bean 是否是单例（<code>mbd.isSingleton()</code>）并且允许循环依赖（<code>this.allowCircularReferences</code>）并且 bean 正在被创建（<code>isSingletonCurrentlyInCreation(beanName)</code>，前面介绍过了），earlySingletonExposure 在这里为 true（前面两个条件一般情况下都是 true ，第三个条件根据前面的介绍也是为 true）</p>
<p><code>DefaultSingletonBeanRegistry.addSingletonFactory</code> 逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">//将bean加入三级缓存</span></span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>earlySingletonExposure 为 true 说明 bean 可以提早暴露，<code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code>就是将 bean 先放入三级缓存，不过留意到这里加入三级缓存的是一个 ObjectFactory （先记住后面会提到）</p>
<p>关注点 10 主要是初始化 bean，<code>populateBean(beanName, mbd, instanceWrapper)</code>依赖注入，<code>exposedObject = initializeBean(beanName, exposedObject, mbd)</code>初始化 bean ，在这个测试例子中 TestClassA 需要注入 TestClassB，尝试从缓存获取 TestClassB 对应的 bean，但是因为 TestClassB 对应的 bean 还未被创建，所以和 TestClassA 创建 bean 的过程一样创建 TestClassB 的 bean，按照前面的逻辑走到 <code>populateBean(beanName, mbd, instanceWrapper)</code> 这一步，发现 TestClassB 中需要依赖 TestClassA，这个时候就从缓存中获取 TestClassA 的 bean，就是关注点 1 中的<code>Object sharedInstance = getSingleton(beanName)</code>(留意 allowEarlyReference 为 true 才会从三级缓存中获取)，在三级缓存中获取到 TestClassA 的 ObjectFactory，通过 <code>singletonObject = singletonFactory.getObject()</code> 获取到 TestClassA 的 bean，之后通过<code>this.earlySingletonObjects.put(beanName, singletonObject)</code> 和 <code>this.singletonFactories.remove(beanName)</code>这两段代码将 TestClassA bean 放入到二级缓存，将 TestClassA 的 ObjectFactory 从三级缓存中移除</p>
<p>从上面的分析可以知道<code>singletonObject = singletonFactory.getObject()</code>这段获取 TestClassA 的 bean 其实调用的就是<code>AbstractAutowireCapableBeanFactory.getEarlyBeanReference</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/8a7649a6a3d6a76ec59657ba29943a0.png" alt="图片丢失" title="图1"></p>
<p><code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractAutoProxyCreator.getEarlyBeanReference</code> 逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>返回的就是传进去的 bean，但是 AbstractAutoProxyCreator 重写了 getEarlyBeanReference ，它其实就是 Spring 的代理实现，返回 bean 的代理对象，传入的 bean 被存放在代理对象的 target 成员变量中（如果不懂的话可以去了解一下代理模式，了解一下静态代理和动态代理是如何实现的），我们这里 TestClassA 上用到声明式事务（@Transactional 注解），所以这里 TestClassA 对应的 bean 不能返回原来的 bean，而是被 AbstractAutoProxyCreator 处理后的代理对象（后面都以 ProxyTestClassA 命名代理类），最后将 ProxyTestClassA 的 bean 注入到 TestClassB 的 bean 中，到此 TestClassB 的 bean 基本已经初始化完成，之后就是回到关注点 6 和关注点 7</p>
<p><code>afterSingletonCreation(beanName)</code>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterSingletonCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Singleton &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 TestClassB 的 bean 已经完成实例化和初始化，所以将 TestClassB 的 beanName 从标记正在创建中的 singletonsCurrentlyInCreation 集合中移除</p>
<p><code>addSingleton(beanName, singletonObject)</code>的逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//将bean放入一级缓存</span></span><br><span class="line">        <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addSingleton(beanName, singletonObject)</code>就是将 TestClassB 的 bean 放入一级缓存，并且将 bean 从二级和三级缓存中移除</p>
<p>之后就是回到关注点 10 的 TestClassA 的 bean 初始化（注意 TestClassA 的 bean 其实还初始化完成，前面说的一堆实例化和初始化 TestClassB 的 bean 逻辑都是因为 TestClassA 的 bean 需要注入 TestClassB 的 bean 导致的），将 TestClassB 的 bean 注入 TestClassA 的 bean 中，这个对于 TestClasA 的 bean 的处理基本完成，但是和 TestClassB 的创建和初始化有点不同的是在关注点 11</p>
<p>关注点 11 的<code>Object earlySingletonReference = getSingleton(beanName, false)</code>(这里传入的 allowEarlyReference 就是为 false 最多只会从二级缓存获取)，前面二级缓存中存入了 TestClassA 的代理类 ProxyTestClassA 的 bean，所以通过 beanName 获取到的就是 ProxyTestClassA 的 bean,所以最后返回就是 earlySingletonReference(指向 ProxyTestClassA 的 bean 并且里面 target 指向的被代理 TestClassA 的 bean 已经初始化完成)，之后的逻辑就和 TestClassB 的一样了</p>
<h4 id="是否一定要使用三级缓存"><a href="#是否一定要使用三级缓存" class="headerlink" title="是否一定要使用三级缓存"></a>是否一定要使用三级缓存</h4>]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Javaweb从web.xml 到 springboot</title>
    <url>/2022/01/21/Javaweb%E4%BB%8Eweb.xml%20%E5%88%B0%20springboot/</url>
    <content><![CDATA[<h3 id="Javaweb-从-web-xml-到-springboot"><a href="#Javaweb-从-web-xml-到-springboot" class="headerlink" title="Javaweb 从 web.xml 到 springboot"></a>Javaweb 从 web.xml 到 springboot</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这篇文章依然是参考了<a href="https://www.cnkirito.moe/servlet-explore/#Initializer-%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA-TomcatStarter">这位大佬的文章</a>，讲得已经非常细了，真的非常建议去看下大佬的文章。</p>
<p>几乎所有人都是从 servlet，jsp，filter 开始编写自己的第一个 hello world 工程。那时，还离不开 web.xml 的配置，在 xml 文件中编写繁琐的 servlet 和 filter 的配置。随着 spring 的普及，配置逐渐演变成了两种方式—java configuration 和 xml 配置共存。现如今，springboot 的普及，java configuration 成了主流，xml 配置似乎已经“灭绝”了。不知道你有没有好奇过，这中间都发生了哪些改变，web.xml 中的配置项又是被什么替代项取代了？</p>
<h4 id="servlet3-0-以前的时代（使用-web-xml-配置）"><a href="#servlet3-0-以前的时代（使用-web-xml-配置）" class="headerlink" title="servlet3.0 以前的时代（使用 web.xml 配置）"></a>servlet3.0 以前的时代（使用 web.xml 配置）</h4><p>项目的结构和部分代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/6aa20d76-53bb-4934-92fb-b3ef599f3907.png" alt="图片丢失" title="项目的结构"></p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;触发 hello world 过滤器...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 servlet3.0 之前需要将需要上面的 HelloWorldServlet 和 HelloWorldFilter 配置在<code>WEB-INF/web.xml</code>文件里面才会生效</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorldServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>top.ouzhanbo.webxml.servlet.HelloWorldServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorldServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HelloWorldFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>top.ouzhanbo.webxml.filter.HelloWorldFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HelloWorldFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="servlet3-0-新特性"><a href="#servlet3-0-新特性" class="headerlink" title="servlet3.0 新特性"></a>servlet3.0 新特性</h4><p>Servlet 3.0 作为 Java EE 6 规范体系中一员，随着 Java EE 6 规范一起发布。该版本在前一版本（Servlet 2.5）的基础上提供了若干新特性用于简化 Web 应用的开发和部署。其中一项新特性便是提供了无 xml 配置的特性。</p>
<p>servlet3.0 首先提供了 @WebServlet，@WebFilter 等注解，这样便有了抛弃 web.xml 的第一个途径，凭借注解声明 servlet 和 filter 来做到这一点。</p>
<p>除了这种方式，servlet3.0 规范还提供了更强大的功能，可以在运行时动态注册 servlet ，filter，listener。以 servlet 为例，过滤器与监听器与之类似。ServletContext 为动态配置 Servlet 增加了如下方法：</p>
<ul>
<li>ServletRegistration.Dynamic addServlet(String servletName,Class&lt;? extends Servlet&gt; servletClass)</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, String className)</li>
<li>T createServlet(Class clazz)</li>
<li>ServletRegistration getServletRegistration(String servletName)</li>
<li>Map<String,? extends ServletRegistration> getServletRegistrations()</li>
</ul>
<p>其中前三个方法的作用是相同的，只是参数类型不同而已；通过 createServlet()方法创建的 Servlet，通常需要做一些自定义的配置，然后使用 addServlet() 方法来将其动态注册为一个可以用于服务的 Servlet。两个 getServletRegistration() 方法主要用于动态为 Servlet 增加映射信息，这等价于在 web.xml 中使用 标签为存在的 Servlet 增加映射信息。上面的 ServletRegistration.Dynamic 看源码发现其实他是继承了 ServletRegistration（FilterRegistration 也是类似）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletRegistration</span> <span class="keyword">extends</span> <span class="title class_">Registration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">Dynamic</span> <span class="keyword">extends</span> <span class="title class_">ServletRegistration</span>, Registration.Dynamic &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadOnStartup</span><span class="params">(<span class="type">int</span> loadOnStartup)</span>;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">setServletSecurity</span><span class="params">(ServletSecurityElement constraint)</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMultipartConfig</span><span class="params">(MultipartConfigElement multipartConfig)</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunAsRole</span><span class="params">(String roleName)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上 ServletContext 新增的方法要么是在 ServletContextListener 的 contexInitialized 方法中调用，要么是在 ServletContainerInitializer 的 onStartup() 方法中调用。</p>
<p>ServletContainerInitializer 也是 Servlet 3.0 新增的一个接口，容器在启动时使用 JAR 服务 API(JAR Service API) 来发现 ServletContainerInitializer 的实现类，并且容器将 WEB-INF/lib 目录下 JAR 包中的类都交给该类的 onStartup()方法处理，我们通常需要在该实现类上使用 @HandlesTypes 注解来指定希望被处理的类，过滤掉不希望给 onStartup() 处理的类。</p>
<p>servlet3.0+的项目结构和部分代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/f27438f5-f759-4995-a322-997d77f1f59c.jpg" alt="图片丢失" title="项目结构"></p>
<p>我并未对 HelloWorldServlet 和 HelloWorldFilter 做任何改动，而是新增了一个 CustomServletContainerInitializer , 它实现了 <code>javax.servlet.ServletContainerInitializer</code> 接口，用来在 web 容器启动时加载指定的 servlet 和 filter，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">JAR_HELLO_URL</span> <span class="operator">=</span> <span class="string">&quot;/hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建 helloWorldServlet...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">servlet</span> <span class="operator">=</span> servletContext.addServlet(</span><br><span class="line">                HelloWorldServlet.class.getSimpleName(),</span><br><span class="line">                HelloWorldServlet.class);</span><br><span class="line">        servlet.addMapping(JAR_HELLO_URL);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建 helloWorldFilter...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FilterRegistration.<span class="type">Dynamic</span> <span class="variable">filter</span> <span class="operator">=</span> servletContext.addFilter(</span><br><span class="line">                HelloWorldFilter.class.getSimpleName(), HelloWorldFilter.class);</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;DispatcherType&gt; dispatcherTypes = EnumSet.allOf(DispatcherType.class);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.REQUEST);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.FORWARD);</span><br><span class="line"></span><br><span class="line">        filter.addMappingForUrlPatterns(dispatcherTypes, <span class="literal">true</span>, JAR_HELLO_URL);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletContext 我们称之为 servlet 上下文，它维护了整个 web 容器中注册的 servlet，filter，listener，以 servlet 为例，可以使用 servletContext.addServlet 等方法来添加 servlet。在上面没用到方法入参中<code>Set&lt;Class&lt;?&gt;&gt; c</code>和注解<code>@HandlesTypes</code>，这里说下这两个东西的作用，<code>@HandlesTypes</code>注解上可以指定需要处理的类，onStartup 方法被调用时将<code>@HandlesTypes</code>中指定类的子类（一定记住是子类，该类的本身不算）放入<code>Set&lt;Class&lt;?&gt;&gt; c</code>这个集合中，如果没有使用<code>@HandlesTypes</code>注解指定处理的类，那<code>Set&lt;Class&lt;?&gt;&gt; c</code>就为<code>null</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/4ad2fa68-43c2-4504-ad14-71f1907d6b03.jpg" alt="图片丢失" title="@HandlesTypes注解Set&lt; Class &lt; ? &gt; &gt; c为null"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/ad20c5eb-720e-4c78-8e7f-46a72a187594.jpg" alt="图片丢失" title="HelloWorldServlet这个类本身不会被放入Set&lt; Class &lt; ? &gt; &gt; c"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/0c06a34c-fdde-49e9-8c9b-212a48fdaf5e.jpg" alt="图片丢失" title="HttpServlet子类HelloWorldServlet才会被放入Set&lt; Class &lt; ? &gt; &gt; c"></p>
<p>这么声明一个 ServletContainerInitializer 的实现类，web 容器并不会识别它，所以，需要借助 SPI 机制(如果不懂 SPI 的可以看看<a href="https://ouzhanbo.top/2021/12/16/SPI%E6%9C%BA%E5%88%B6/">这篇文章</a>)来指定该初始化类，这一步骤是通过在项目路径下创建 <code>META-INF/services/javax.servlet.ServletContainerInitializer</code> 来做到的，它只包含一行内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top.ouzhanbo.websci.CustomServletContainerInitializer</span><br></pre></td></tr></table></figure>
<p>使用 ServletContainerInitializer 和 SPI 机制，我们的 web 应用便可以彻底摆脱 web.xml 了。</p>
<p>在 ContextConfig 类中可以看到通过 SPI 加载 ServletContainerInitializer 的实现类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ServletContainerInitializer&gt; detectedScis;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    WebappServiceLoader&lt;ServletContainerInitializer&gt; loader = <span class="keyword">new</span> <span class="title class_">WebappServiceLoader</span>&lt;&gt;(context);</span><br><span class="line">    <span class="comment">//SPI加载ServletContainerInitializer的实现类</span></span><br><span class="line">    detectedScis = loader.load(ServletContainerInitializer.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(sm.getString(</span><br><span class="line">            <span class="string">&quot;contextConfig.servletContainerInitializerFail&quot;</span>,</span><br><span class="line">            context.getName()),</span><br><span class="line">        e);</span><br><span class="line">    ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 StandardContext 类中可以看到 ServletContainerInitializer 的 onStartup 方法被调用的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call ServletContainerInitializers</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">&quot;standardContext.sciFail&quot;</span>), e);</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring-是如何支持-servlet3-0-的？"><a href="#Spring-是如何支持-servlet3-0-的？" class="headerlink" title="Spring 是如何支持 servlet3.0 的？"></a>Spring 是如何支持 servlet3.0 的？</h4><p>在我最初接触 spring 的时候虽然已经有 servlet3.0 但是那时候都是在网上找一些视频来学习的，基本都是学到能用就觉得可以了，当时学的 springmvc+spring+mybatis 里面的 spirngmvc 和 spring 的配置都是用 xml 的，但是当时其实不是很懂 web.xml 中配的那个 listener 和 servlet 标签里面的那个初始化参数标签 init-param 里面那个东西有什么用，后来 springboot 出来后基本就用 springboot 了基本没在用过 ssm 那一套了，所以 spring 搭配 servlet3.0 那套无 xml 配置的方式我完全没用过，看了<a href="https://www.cnkirito.moe/servlet-explore/#Initializer-%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA-TomcatStarter">这位大佬的文章</a>加上百度再搜索了一波资料加上自己调试，现在大概弄懂了用 xml 和用 javaConfig 这两种方式浅显的原理。</p>
<h5 id="使用-xml-配置的方式"><a href="#使用-xml-配置的方式" class="headerlink" title="使用 xml 配置的方式"></a>使用 xml 配置的方式</h5><p>先看看项目的结构和部分的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/44b0d7d3-5227-44b9-8a84-f5ce02705d07.jpg" alt="图片丢失" title="通过xml配置的情况下使用Spring"></p>
<p>代码和配置如下</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet容器初始化时的参数，可以通过servletContext.getInitParameter(&quot;contextConfigLocation&quot;)获取   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/application.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置servlet容器的监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的初始化时的参数，可以在DispatcherServlet里通过getInitParameter(&quot;contextConfigLocation&quot;)获取 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/application-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet的加载顺序，如果是为负数就是在第一次请求该servlet时候才会加载，当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet，正数的值越小，该servlet的优先级越高，应用启动时就越先加载   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring 的配置 application.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring容器扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.ouzhanbo.webspring&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不扫描spring mvc的controller --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringMvc 的配置 application-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring mvc扫描controller不扫描service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.ouzhanbo.webspring&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyController 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 web.xml 上面配置的监听器 ContextLoaderListener 继承 ContextLoader 类并实现了 ServletContextListener 接口，实现了 ServletContextListener 接口的监听器会监听 servelet 容器，在 servelet 容器启动和关闭时会触发该监听器</p>
<p>ServletContextListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletContextListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//servlet容器启动时调用</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//servlet容器销毁时调用</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextLoaderListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContextLoaderListener <span class="keyword">extends</span> <span class="title class_">ContextLoader</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ContextLoaderListener</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">//创建并且初始化Spring容器</span></span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> &#123;</span><br><span class="line">    closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Tomcat 源码，在 StandardContext 里面的 listenerStart 方法里面有段代码就是获取 ServletContextListener 接口的实现类并且调用它的 contextInitialized 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object instances[] = getApplicationLifecycleListeners();</span><br><span class="line">       <span class="keyword">if</span> (instances == <span class="literal">null</span> || instances.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> ok;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">ServletContextEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextEvent</span>(getServletContext());</span><br><span class="line">       <span class="type">ServletContextEvent</span> <span class="variable">tldEvent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (noPluggabilityListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           noPluggabilityServletContext = <span class="keyword">new</span> <span class="title class_">NoPluggabilityServletContext</span>(getServletContext());</span><br><span class="line">           tldEvent = <span class="keyword">new</span> <span class="title class_">ServletContextEvent</span>(noPluggabilityServletContext);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Object instance : instances) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> ServletContextListener)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获取实现了ServletContextListener的监听器</span></span><br><span class="line">           <span class="type">ServletContextListener</span> <span class="variable">listener</span> <span class="operator">=</span> (ServletContextListener) instance;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               fireContainerEvent(<span class="string">&quot;beforeContextInitialized&quot;</span>, listener);</span><br><span class="line">               <span class="keyword">if</span> (noPluggabilityListeners.contains(listener)) &#123;</span><br><span class="line">                   listener.contextInitialized(tldEvent);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//调用contextInitialized方法</span></span><br><span class="line">                   listener.contextInitialized(event);</span><br><span class="line">               &#125;</span><br><span class="line">               fireContainerEvent(<span class="string">&quot;afterContextInitialized&quot;</span>, listener);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               ExceptionUtils.handleThrowable(t);</span><br><span class="line">               fireContainerEvent(<span class="string">&quot;afterContextInitialized&quot;</span>, listener);</span><br><span class="line">               getLogger().error(sm.getString(<span class="string">&quot;standardContext.listenerStart&quot;</span>,</span><br><span class="line">                       instance.getClass().getName()), t);</span><br><span class="line">               ok = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>之后就是调用 ContextLoader 的 initWebApplicationContext 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">  <span class="comment">//先判断是不是已经创建过了spring的根容器（大部分被spring管理的类都放在这里面，比如被@Service @@Repository，@Component注解标注的类）</span></span><br><span class="line">  <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;Cannot initialize context because there is already a root application context present - &quot;</span> +</span><br><span class="line">        <span class="string">&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  servletContext.log(<span class="string">&quot;Initializing Spring root WebApplicationContext&quot;</span>);</span><br><span class="line">  <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(ContextLoader.class);</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Root WebApplicationContext: initialization started&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">    <span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有在context-param里面指定ContextLoader里面的contextClass的值的话，默认使用的时org.springframework.web.context.support.XmlWebApplicationContext这个类的创建的容器（感兴趣的话可以点进去看下就知道了）</span></span><br><span class="line">      <span class="built_in">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">      <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) <span class="built_in">this</span>.context;</span><br><span class="line">      <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">        <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">        <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">        <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">          <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">          <span class="type">ApplicationContext</span> <span class="variable">parent</span> <span class="operator">=</span> loadParentContext(servletContext);</span><br><span class="line">          cwac.setParent(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终会到这里，看方法名配置并刷新web应用容器</span></span><br><span class="line">        configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将spring容器保存到servlet容器中</span></span><br><span class="line">    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.context);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">      currentContext = <span class="built_in">this</span>.context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">      currentContextPerThread.put(ccl, <span class="built_in">this</span>.context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">      logger.info(<span class="string">&quot;Root WebApplicationContext initialized in &quot;</span> + elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configureAndRefreshWebApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIG_LOCATION_PARAM</span> <span class="operator">=</span> <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">      <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">      <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">idParam</span> <span class="operator">=</span> sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">      <span class="keyword">if</span> (idParam != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setId(idParam);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Generate default id...</span></span><br><span class="line">        wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">            ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(sc);</span><br><span class="line">    <span class="comment">//这里的CONFIG_LOCATION_PARAM就是contextConfigLocation，这里就是获取到在web.xml中context-param配置contextConfigLocation的值classpath*:/application.xml</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocationParam</span> <span class="operator">=</span> sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (configLocationParam != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//将spring容器的配置文件application.xml的放入到容器中，后面调用wac.refresh()会用到</span></span><br><span class="line">      wac.setConfigLocation(configLocationParam);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">      ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customizeContext(sc, wac);</span><br><span class="line">    wac.refresh();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 refresh 方法里面的层层深入后 XmlWebApplicationContext 这个类的 loadBeanDefinitions 方法里面看到之前保存的 spring 容器的配置文件路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/3b086659-4b39-467f-877e-0b8db6b56bd1.png" alt="图片丢失" title="loadBeanDefinitions加载application.xml"></p>
<p>之后就是 spring 的加载配置文件的源码了，这里就不展开了（我也没怎么看过），讲那么多其实最关键的就是知道 Spring 容器是通过在 Servlet 容器初始化的时候调用监听器 ContextLoaderListener 的 contextInitialized 方法加载到 Servlet 容器中的。</p>
<p>那么 springmvc 的容器是在哪里加载进来的呢？其实不难猜到就在 DispatcherServlet 初始化的时候加载进来的，在 StandardWrapper 里的 loadServlet 方法里通过反射的方式创建了 servlet 实例并且将其返回给了上层的 load 方法，并且在上层的 load 方法中通过调用 initServlet 方法最终调用到 servlet 的 init 方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/04237254-ea0d-499e-b3c2-16775a770d0d.jpg" alt="图片丢失" title="StandardWrapper的loadServlet里创建servelet对象"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/b0909736-c773-45e4-b5e5-59539bf170ce.jpg" alt="图片丢失" title="StandardWrapper的load方法调用了initServlet方法"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/2f380a44-8634-4952-a81d-4e9ea7133799.jpg" alt="图片丢失" title="StandardWrapper的initServlet调用servlet的初始化init方法"></p>
<p>如果 servlet 是 FrameworkServlet 类或者其子类（DispatcherServlet 继承 FrameworkServlet）的实例那么层层深入后最终会调用到 FrameworkServlet 的 initWebApplicationContext 方法</p>
<p>initWebApplicationContext 方法的的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//这里代码如果深入的话会发现这里的rootContext就是我们上面保存到servlet容器里面的spring容器</span></span><br><span class="line">  <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">      WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">  <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">    wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">    <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">      <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">      <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">        <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">        <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">        <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">          <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">          cwac.setParent(rootContext);</span><br><span class="line">        &#125;</span><br><span class="line">        configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">    <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">    <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">    <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">    wac = findWebApplicationContext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//会调用到这里</span></span><br><span class="line">    <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">    wac = createWebApplicationContext(rootContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">    <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">    <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">    <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">      onRefresh(wac);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">    <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">    <span class="comment">//attraName的值由FrameworkServlet.class.getName() + &quot;.CONTEXT.&quot; + getServletName()组合成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">    <span class="comment">//将springmvc容器以attraName的名字保存在servlet容器里</span></span><br><span class="line">    getServletContext().setAttribute(attrName, wac);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initWebApplicationContext 会调用到 createWebApplicationContext，最会调用到 createWebApplicationContext(@Nullable ApplicationContext parent) 方法</p>
<p>createWebApplicationContext(@Nullable ApplicationContext parent) 方法的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">  <span class="comment">//可以在web.xml里面servlet标签里面的init-param标签里设置contextClass的值，默认值是XmlWebApplicationContext.class</span></span><br><span class="line">  Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">  <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">        <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">        <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">        <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">      (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">  wac.setEnvironment(getEnvironment());</span><br><span class="line">  wac.setParent(parent);</span><br><span class="line">  <span class="comment">//可以在web.xml里面servlet标签里面的init-param标签里设置contextConfigLocation的值，这里获取到值是classpath*:/application-mvc.xml</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">  <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">    wac.setConfigLocation(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line">  configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 contextClass 和 contextConfigLocation 的值都是在 HttpServletBean（FrameworkServlet 的父类）的 init 方法中被赋予</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/00c97827-4f26-4cbf-8a71-6b243b9bda75.jpg" alt="图片丢失" title="将web.xml里servlet标签里的init-param标签设置的servlet初始化的值设置到servlet对应名字的属性里"></p>
<p>最终将 springmvc 的容器保存在 servlet 容器中，这样 springmvc 就成功的加载进来了</p>
<h5 id="完全无-xml-的配置方式"><a href="#完全无-xml-的配置方式" class="headerlink" title="完全无 xml 的配置方式"></a>完全无 xml 的配置方式</h5><p>项目的结构和部分的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/a2596a50-a161-4e7d-b916-bf04cc451d4f.jpg" alt="图片丢失" title="完全无xml的配置方式下的项目结构"></p>
<p>MyConfig 配置类的效果和上面用 xml 的方式时的 application.xml 类似，主要的针对 Spring 容器的，上面的@ComponentScan 注解的内容是告诉 Spring 容器扫描并且加载 top.ouzhanbo.webspring 下的所有被@Service 注解标注的类，useDefaultFilters = false 是为了防止 spring 默认会自动发现被 @Component、@Repository、@Service 和 @Controller 标注的类，并注册进容器中这行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//告诉Spring容器扫描并且加载top.ouzhanbo.webspring下的所有被@Service注解标注的类</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;top.ouzhanbo.webspring&quot;,includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Service.class&#125;)&#125;,useDefaultFilters = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyMvcConfig 配置类和上面的 MyConfig 配置类差不多，只是这个是针对 SpringMvc 容器的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//告诉SpringMvc容器扫描并且加载top.ouzhanbo.webspring下的所有被@Controller注解标注的类</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;top.ouzhanbo.webspring&quot;,includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;,useDefaultFilters = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyController 的代码很简单，就是返回一个 hello 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebInitializer 这个类这里先不介绍后面再说</p>
<p>前面介绍的 servlet3.0 下是如何通过 SPI 的方式注册 Servlet、Filter、Listener 的，其实在无 xml 配置的情况下 Spring 也是通过这种方式来注册 Servlet、Filter、Listener，找到 ServletContainerInitializer 的实现类 SpringServletContainerInitializer</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/98e9a2e0-02a8-4a9b-983b-f7aaff87b84c.jpg" alt="图片丢失" title="META-INF/S/services/javax.servlet.ServletContainerInitializer"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes(WebApplicationInitializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(<span class="meta">@Nullable</span> Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;WebApplicationInitializer&gt; initializers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (webAppInitializerClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">      initializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(webAppInitializerClasses.size());</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">        <span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span><br><span class="line">        <span class="comment">// no matter what @HandlesTypes says...</span></span><br><span class="line">        <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">            WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取到所有WebApplicationInitializer类的子类（除了接口和抽象类）并且通过反射创建该类的实例</span></span><br><span class="line">            initializers.add((WebApplicationInitializer)</span><br><span class="line">                ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to instantiate WebApplicationInitializer class&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">      servletContext.log(<span class="string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servletContext.log(initializers.size() + <span class="string">&quot; Spring WebApplicationInitializers detected on classpath&quot;</span>);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">    <span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">            <span class="comment">//调用WebApplicationInitializer的onStartup方法</span></span><br><span class="line">      initializer.onStartup(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringServletContainerInitializer 的 onStartup 方法的作用就是找到所有 WebApplicationInitializer 类的子类（除了接口和抽象类）并且调用它们的 onStartup 方法（套娃吖），而我们上面的 WebInitializer 就是 WebApplicationInitializer 的子类</p>
<p>WebInitializer 的继承关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/a007d899-eca2-4c32-94d2-709997de5177.png" alt="图片丢失" title="WebInitializer的继承关系"></p>
<p>WebInitializer 的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">//返回Spring容器对应的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;MyConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">//返回SpringMvc容器对应的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;MyMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">//返回DispatcherServlet的拦截路径，在ServletRegistration.Dynamic的addMapping方法里面用到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebInitializer 的 onStartup 的方法在它的父类 AbstractDispatcherServletInitializer 中实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDispatcherServletInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractContextLoaderInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_SERVLET_NAME</span> <span class="operator">=</span> <span class="string">&quot;dispatcher&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//WebInitializer的onStartup的方法在它的父类AbstractDispatcherServletInitializer中实现</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">//调用父类的AbstractContextLoaderInitializer的onStartup方法</span></span><br><span class="line">    <span class="built_in">super</span>.onStartup(servletContext);</span><br><span class="line">    <span class="comment">//主要的作用是创建SpringMvc容器并且将DispatcherServlet注册到Servlet容器中</span></span><br><span class="line">    registerDispatcherServlet(servletContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDispatcherServlet</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="comment">//默认的名字是dispatcher</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> getServletName();</span><br><span class="line">    Assert.hasLength(servletName, <span class="string">&quot;getServletName() must not return null or empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createServletApplicationContext这个方法在其子类AbstractAnnotationConfigDispatcherServletInitializer中实现，起作用是创建并且返回spirngMvc容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">servletAppContext</span> <span class="operator">=</span> createServletApplicationContext();</span><br><span class="line">    Assert.notNull(servletAppContext, <span class="string">&quot;createServletApplicationContext() must not return null&quot;</span>);</span><br><span class="line">    <span class="comment">//createDispatcherServlet创建并且返回DispatcherServlet实例</span></span><br><span class="line">    <span class="type">FrameworkServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> createDispatcherServlet(servletAppContext);</span><br><span class="line">    Assert.notNull(dispatcherServlet, <span class="string">&quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;</span>);</span><br><span class="line">    dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将DispatcherServlet注册到Servlet容器中</span></span><br><span class="line">    ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(servletName, dispatcherServlet);</span><br><span class="line">    <span class="keyword">if</span> (registration == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to register servlet with name &#x27;&quot;</span> + servletName + <span class="string">&quot;&#x27;. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Check if there is another servlet registered under the same name.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的代码的作用和在web.xml配置的&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;一样</span></span><br><span class="line">    registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里getServletMappings方法调用的就是是我在WebInitializer实现的getServletMappings方法</span></span><br><span class="line">    registration.addMapping(getServletMappings());</span><br><span class="line">    registration.setAsyncSupported(isAsyncSupported());</span><br><span class="line"></span><br><span class="line">    Filter[] filters = getServletFilters();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(filters)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        <span class="comment">//将针对DispatcherServlet的Filter注册到Servlet容器中</span></span><br><span class="line">        registerServletFilter(servletContext, filter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户可以重写这个方法对DispatcherServlet做一些配置，例如我想设置一下DispatcherServlet的加载顺序就重写该方法在里面加一个语句registration.setLoadOnStartup(2);</span></span><br><span class="line">    customizeRegistration(registration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String <span class="title function_">getServletName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DEFAULT_SERVLET_NAME;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建并且返回DispatcherServlet实例</span></span><br><span class="line">  <span class="keyword">protected</span> FrameworkServlet <span class="title function_">createDispatcherServlet</span><span class="params">(WebApplicationContext servletAppContext)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(servletAppContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> String[] getServletMappings();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> FilterRegistration.Dynamic <span class="title function_">registerServletFilter</span><span class="params">(ServletContext servletContext, Filter filter)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> Conventions.getVariableName(filter);</span><br><span class="line">    <span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addFilter(filterName, filter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registration == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (registration == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter == <span class="number">100</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to register filter with name &#x27;&quot;</span> + filterName + <span class="string">&quot;&#x27;. &quot;</span> +</span><br><span class="line">              <span class="string">&quot;Check if there is another filter registered under the same name.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registration = servletContext.addFilter(filterName + <span class="string">&quot;#&quot;</span> + counter, filter);</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registration.setAsyncSupported(isAsyncSupported());</span><br><span class="line">    registration.addMappingForServletNames(getDispatcherTypes(), <span class="literal">false</span>, getServletName());</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> EnumSet&lt;DispatcherType&gt; <span class="title function_">getDispatcherTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (isAsyncSupported() ?</span><br><span class="line">        EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :</span><br><span class="line">        EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用户可以重写这个方法对DispatcherServlet做一些配置</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractDispatcherServletInitializer 的父类 AbstractContextLoaderInitializer 的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractContextLoaderInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在子类AbstractDispatcherServletInitializer中通过super.onStartup(servletContext)调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">//创建Spring容器和Servlet容器的监听器，并且将监听器注册到Servlet容器中</span></span><br><span class="line">    registerContextLoaderListener(servletContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerContextLoaderListener</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="comment">//createRootApplicationContext这个方法在其子类AbstractAnnotationConfigDispatcherServletInitializer中实现，这个方法创建并且返回一个spring容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootAppContext</span> <span class="operator">=</span> createRootApplicationContext();</span><br><span class="line">    <span class="keyword">if</span> (rootAppContext != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建Servlet容器的监听器（ContextLoaderListener实现了ServletContextListener），并且将Spring容器的实例作为参数传入</span></span><br><span class="line">      <span class="type">ContextLoaderListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(rootAppContext);</span><br><span class="line">      listener.setContextInitializers(getRootApplicationContextInitializers());</span><br><span class="line">      <span class="comment">//将监听器注册到servlet容器中</span></span><br><span class="line">      servletContext.addListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;No ContextLoaderListener registered, as &quot;</span> +</span><br><span class="line">          <span class="string">&quot;createRootApplicationContext() did not return an application context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AbstractDispatcherServletInitializer 的 createServletApplicationContext 方法和 AbstractContextLoaderInitializer 的 createRootApplicationContext 方法都是在子类 AbstractAnnotationConfigDispatcherServletInitializer 中实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//getRootConfigClasses这个方法在我实现的子类WebInitializer中有实现了，返回的是Spring容器的配置类，在这个案例就是MyConfig.class</span></span><br><span class="line">    Class&lt;?&gt;[] configClasses = getRootConfigClasses();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span><br><span class="line">      <span class="comment">//创建Spring容器实例</span></span><br><span class="line">      <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">      <span class="comment">//将配置类注册到容器中</span></span><br><span class="line">      context.register(configClasses);</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建SpringMvc容器</span></span><br><span class="line">    <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">    <span class="comment">//getServletConfigClasses这个方法在我实现的子类WebInitializer中有实现了，返回的是SpringMvc容器的配置类，在这个案例就是MyMvcConfig.class</span></span><br><span class="line">    Class&lt;?&gt;[] configClasses = getServletConfigClasses();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span><br><span class="line">      context.register(configClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面代码和注释可以看出 WebInitializer 的 onStartup 方法其实主要做了几件事：</p>
<ol>
<li>创建 Spring 容器，获取 Spring 容器对应的配置类并且把配置类注册到 Spring 容器，将 Spring 容器作为参数传入创建 Servlet 容器的监听器（ContextLoaderListener 实现了 ServletContextListener），将监听器注册到 servlet 容器中</li>
<li>创建 SpringMvc 容器，获取 SpringMvc 容器对应的配置类并且把配置类注册到 SpringMvc 容器，将 SpringMvc 容器作为参数传入创建 DispatcherServlet 实例，并且将 DispatcherServlet 实例注册 Servlet 容器中</li>
</ol>
<p>之后的流程就和上面使用 xml 的方式差不多，在 Servelt 容器监听器 ContextLoaderListener 里的 contextInitialized 方法里面对 Spring 容器进初始化等一些操作，并且将 Spring 容器保存到 servlet 容器中，SpringMvc 容器也是在 Servlet 的 init 方法里面对 SpringMvc 容器进行初始化等一些操作，最终将 SpringMvc 容保存到 servlet 容器中。这里只是简单的描述一下，具体的流程可以按照上面 xml 里面分析的流程去调试代码，这样会比较清晰而且会有不错的收获。</p>
<h4 id="SpringBoot-是如何加载-Servlet-的"><a href="#SpringBoot-是如何加载-Servlet-的" class="headerlink" title="SpringBoot 是如何加载 Servlet 的"></a>SpringBoot 是如何加载 Servlet 的</h4><p>SpringBoot 加载 servlet 和 filter 的方式和前面说的使用 web,xml 和使用 SPI 来加载 ServletContainerInitializer 实现类的方法都不同。下面先来看看在 SpringBoot 中 servlet 和 filter 的几种注册方式</p>
<h5 id="注册方式一：servlet3-0-注解-ServletComponentScan"><a href="#注册方式一：servlet3-0-注解-ServletComponentScan" class="headerlink" title="注册方式一：servlet3.0 注解 +@ServletComponentScan"></a>注册方式一：servlet3.0 注解 +@ServletComponentScan</h5><p>SpringBoot 兼容 servlet3.0，可以使用一系列以 Web*开头的注解:@Servlet、@Filter、@WebListener</p>
<p>使用 Servlet3.0 提供的@Servlet 和@WebFilter 注解+@ServletComponentScan 注解</p>
<p>MyFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//里面的initParams的参数类似于在web.xml中filter标签里面的init-param标签里设置的一些初始化参数，这些参数可以通过getInitParameter方法获取</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/myServlet&quot;,initParams = &#123;@WebInitParam(name = &quot;filterName&quot;,value = &quot;myFilter&quot;),@WebInitParam(name = &quot;msg&quot;,value = &quot;被我过滤了&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> getInitParameter(<span class="string">&quot;filterName&quot;</span>) +</span><br><span class="line">                <span class="string">&quot;:&quot;</span> +</span><br><span class="line">                getInitParameter(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        response.getOutputStream().write(msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        response.getOutputStream().write(<span class="string">&quot;&lt;br&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/myServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.getOutputStream().write(<span class="string">&quot;myServlet:哈喽啊！！！&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是几种方式中最为简洁的方式，如果真的有特殊需求，需要在 springboot 下注册 servlet，filter，可以采用这样的方式，比较直观。</p>
<h5 id="注册方式二：RegistrationBean"><a href="#注册方式二：RegistrationBean" class="headerlink" title="注册方式二：RegistrationBean"></a>注册方式二：RegistrationBean</h5><p>MyConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean&lt;HelloWorldServlet&gt; <span class="title function_">helloWorldServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        ServletRegistrationBean&lt;HelloWorldServlet&gt; helloWorldServlet = <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        helloWorldServlet.addUrlMappings(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">        helloWorldServlet.setServlet(<span class="keyword">new</span> <span class="title class_">HelloWorldServlet</span>());</span><br><span class="line">        <span class="keyword">return</span> helloWorldServlet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;HelloWorldFilter&gt; <span class="title function_">helloWorldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;HelloWorldFilter&gt; helloWorldFilter = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        helloWorldFilter.addUrlPatterns(<span class="string">&quot;/hello/*&quot;</span>);</span><br><span class="line">        helloWorldFilter.setFilter(<span class="keyword">new</span> <span class="title class_">HelloWorldFilter</span>());</span><br><span class="line">        <span class="keyword">return</span> helloWorldFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloWorldFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloWorldFilter:被我拦截了&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloWorldServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getOutputStream().write(<span class="string">&quot;helloWorldServlet:被我的处理了&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletRegistrationBean 和 FilterRegistrationBean 都继承自 RegistrationBean ，RegistrationBean 是 springboot 中广泛应用的一个注册类，负责把 servlet，filter，listener 给容器化，使他们被 spring 托管，并且完成自身对 web 容器的注册。这种注册方式也值得推崇。</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/b2318c2a-df88-4880-a8af-ffd0e6fc58b0.png" alt="图片丢失" title="Registration的继承关系"></p>
<p>RegistrationBean 这个类的几个子类 ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean 的作用分别是帮助容器注册 servlet、filter、listener，DelegatingFilterProxyRegistrationBean 这个是用在 SpringSecurity 里的，这笔记力线不管，之后学习 SpringSecurity 的时候才会用到。在这里还需要留意 RegistrationBean 这个类实现了 ServletContextInitializer 接口（注意他和上面说的 ServletContainerInitializer 不是同一个东西），这个接口是一个核心接口，后面还会提到，这里先混个眼熟。</p>
<h5 id="SpringBoot-内置-tomcat-容器加载-servlet-源码分析"><a href="#SpringBoot-内置-tomcat-容器加载-servlet-源码分析" class="headerlink" title="SpringBoot 内置 tomcat 容器加载 servlet 源码分析"></a>SpringBoot 内置 tomcat 容器加载 servlet 源码分析</h5><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/44413ff6-b032-42f9-96c9-d2caf276d357.jpg" alt="图片丢失" title="TomcatStarter"></p>
<p>SpringBoot 使用内置 tomcat 的情况下没有使用前面说到的 SpringServletContainerInitializer，而是使用 ServletContainerInitializer 的另一个实现类 TomcatStarter，但是这个 TomcatStarter 的调用并依赖不依赖于 servlet3.0 规范和 SPI，它走的是另外一套新的逻辑，在 Spring github 的 issue 中作者说了:<a href="https://github.com/spring-projects/spring-boot/issues/321">https://github.com/spring-projects/spring-boot/issues/321</a></p>
<blockquote>
<p>This was actually an intentional design decision. The search algorithm used by the containers was problematic. It also causes problems when you want to develop an executable WAR as you often want a <code>javax.servlet.ServletContainerInitializer</code> for the WAR that is not executed when you run <code>java -jar</code>.</p>
<p>See the <code>org.springframework.boot.context.embedded.ServletContextInitializer</code> for an option that works with Spring Beans.</p>
</blockquote>
<p>springboot 这么做是有意而为之。springboot 考虑到了如下的问题，我们在使用 springboot 时，开发阶段一般都是使用内嵌 tomcat 容器，但部署时却存在两种选择：一种是打成 jar 包，使用 java -jar 的方式运行；另一种是打成 war 包，交给外置容器去运行。前者就会导致容器搜索算法出现问题，因为这是 jar 包的运行策略，不会按照 servlet3.0 的策略去加载 ServletContainerInitializer！最后作者还提供了一个替代选项：ServletContextInitializer，前文还提到 RegistrationBean 实现了 ServletContextInitializer 接口。</p>
<p>在 TomcatStarter 中的 ServletContextInitializer[] initializers 是 springboot 注册 servlet，filter，listener 的关键，先看看 TomcatStarter 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TomcatStarter</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(TomcatStarter.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存放实现了ServletContextInitializer接口的类的实例，例如ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServletContextInitializer[] initializers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Exception startUpException;</span><br><span class="line"></span><br><span class="line">  TomcatStarter(ServletContextInitializer[] initializers) &#123;</span><br><span class="line">    <span class="built_in">this</span>.initializers = initializers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里获取到的ServletContextInitializer的实例并不是我们上面说的RegistrationBean的子类实例</span></span><br><span class="line">      <span class="keyword">for</span> (ServletContextInitializer initializer : <span class="built_in">this</span>.initializers) &#123;</span><br><span class="line">        initializer.onStartup(servletContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="built_in">this</span>.startUpException = ex;</span><br><span class="line">      <span class="comment">// Prevent Tomcat from logging and re-throwing when we know we can</span></span><br><span class="line">      <span class="comment">// deal with it in the main thread, but log for information here.</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Error starting Tomcat context. Exception: &quot;</span> + ex.getClass().getName() + <span class="string">&quot;. Message: &quot;</span></span><br><span class="line">            + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以打断点调试一下，会发现在 TomcatStarter 里面的 ServletContextInitializer[] initializers 里存放的并不是我们上面说的 RegistrationBean 的子类的实例，而是三个用 lambda 表达式实现的匿名内部类的实例，其中在 ServletWebServerApplicationContext 中实现的匿名内部类是是获取 RegistrationBean 子类的实例的核心</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/32a7d016-e2d4-4bbe-8aaf-3210e85b4370.jpg" alt="图片丢失" title="TomcatStarter的onStartup方法调试截图"></p>
<p>想知道这个 ServletWebServerApplicationContext 的实例是在哪被放入 TomcatStarter 中的就要从 main 方法开始一路深入，到 ServletWebServerApplicationContext.createWebServer 前的调用逻辑大概是下面这样，具体自己调试看下比较清楚。</p>
<p>SpringApplication.run =&gt; SpringApplication.refreshContext =&gt; SpringApplication.refresh =&gt; AbstractApplicationContext.refresh</p>
<p>=&gt; ServletWebServerApplicationContext.onRefresh =&gt; ServletWebServerApplicationContext.createWebServer</p>
<p>ServletWebServerApplicationContext 中 createWebServer 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">    <span class="comment">//getWebServer方法和getSelfInitializer方法是两个关键的的方法，我们后面一个个看</span></span><br><span class="line">    <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">    getBeanFactory().registerSingleton(<span class="string">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebServerGracefulShutdownLifecycle</span>(<span class="built_in">this</span>.webServer));</span><br><span class="line">    getBeanFactory().registerSingleton(<span class="string">&quot;webServerStartStop&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebServerStartStopLifecycle</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.webServer));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getWebServer 方法的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">    Registry.disableRegistry();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建tomcat</span></span><br><span class="line">  <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">  <span class="type">File</span> <span class="variable">baseDir</span> <span class="operator">=</span> (<span class="built_in">this</span>.baseDirectory != <span class="literal">null</span>) ? <span class="built_in">this</span>.baseDirectory : createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">  connector.setThrowOnFailure(<span class="literal">true</span>);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="built_in">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在这个方法里面调用了configureContext方法，就是configureContext这个方法创建了TomcatStarter并且将前面说的那几个通过lambda表达式实现的匿名内部类的实例赛道TomcatStarter中的</span></span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareContext 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> &#123;</span><br><span class="line">  <span class="type">File</span> <span class="variable">documentRoot</span> <span class="operator">=</span> getValidDocumentRoot();</span><br><span class="line">  <span class="type">TomcatEmbeddedContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatEmbeddedContext</span>();</span><br><span class="line">  <span class="keyword">if</span> (documentRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">    context.setResources(<span class="keyword">new</span> <span class="title class_">LoaderHidingResourceRoot</span>(context));</span><br><span class="line">  &#125;</span><br><span class="line">  context.setName(getContextPath());</span><br><span class="line">  context.setDisplayName(getDisplayName());</span><br><span class="line">  context.setPath(getContextPath());</span><br><span class="line">  <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> (documentRoot != <span class="literal">null</span>) ? documentRoot : createTempDir(<span class="string">&quot;tomcat-docbase&quot;</span>);</span><br><span class="line">  context.setDocBase(docBase.getAbsolutePath());</span><br><span class="line">  context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">FixContextListener</span>());</span><br><span class="line">  context.setParentClassLoader((<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) ? <span class="built_in">this</span>.resourceLoader.getClassLoader()</span><br><span class="line">      : ClassUtils.getDefaultClassLoader());</span><br><span class="line">  resetDefaultLocaleMapping(context);</span><br><span class="line">  addLocaleMappings(context);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    context.setCreateUploadTargets(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoSuchMethodError ex) &#123;</span><br><span class="line">    <span class="comment">// Tomcat is &lt; 8.5.39. Continue.</span></span><br><span class="line">  &#125;</span><br><span class="line">  configureTldPatterns(context);</span><br><span class="line">  <span class="type">WebappLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebappLoader</span>();</span><br><span class="line">  loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());</span><br><span class="line">  loader.setDelegate(<span class="literal">true</span>);</span><br><span class="line">  context.setLoader(loader);</span><br><span class="line">  <span class="keyword">if</span> (isRegisterDefaultServlet()) &#123;</span><br><span class="line">    addDefaultServlet(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldRegisterJspServlet()) &#123;</span><br><span class="line">    addJspServlet(context);</span><br><span class="line">    addJasperInitializer(context);</span><br><span class="line">  &#125;</span><br><span class="line">  context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">StaticResourceConfigurer</span>(context));</span><br><span class="line">  <span class="comment">//这个方法可以自己看下，可以看到除了我们关键的ServletWebServerApplicationContext中匿名实现的ServletContextInitializer类的实例外，剩下的两个ServletContextInitializer实例就是在这里放入数组</span></span><br><span class="line">  ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);</span><br><span class="line">  host.addChild(context);</span><br><span class="line">  <span class="comment">//在这个方法里创建TomcatStarter并且将上面initializersToUse数组中的ServletContextInitializer实例放入TomcatStarter中的ervletContextInitializer[] initializers</span></span><br><span class="line">  configureContext(context, initializersToUse);</span><br><span class="line">  postProcessContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configureContext 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureContext</span><span class="params">(Context context, ServletContextInitializer[] initializers)</span> &#123;</span><br><span class="line">  <span class="comment">//创建TomcatStarter，并且将ServletContextInitializer实例放入其中</span></span><br><span class="line">  <span class="type">TomcatStarter</span> <span class="variable">starter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatStarter</span>(initializers);</span><br><span class="line">  <span class="keyword">if</span> (context <span class="keyword">instanceof</span> TomcatEmbeddedContext) &#123;</span><br><span class="line">    <span class="type">TomcatEmbeddedContext</span> <span class="variable">embeddedContext</span> <span class="operator">=</span> (TomcatEmbeddedContext) context;</span><br><span class="line">    embeddedContext.setStarter(starter);</span><br><span class="line">    embeddedContext.setFailCtxIfServletStartFails(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将TomcatStarter通过addServletContainerInitializer方法放入servlet容器中，之后实现了ServletContainerInitializer的TomcatStarter的onStartup方法被调用会在StandardContext类中被调用（上面贴过源码，忘了可以回去看看）</span></span><br><span class="line">  context.addServletContainerInitializer(starter, NO_CLASSES);</span><br><span class="line">  <span class="keyword">for</span> (LifecycleListener lifecycleListener : <span class="built_in">this</span>.contextLifecycleListeners) &#123;</span><br><span class="line">    context.addLifecycleListener(lifecycleListener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Valve valve : <span class="built_in">this</span>.contextValves) &#123;</span><br><span class="line">    context.getPipeline().addValve(valve);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ErrorPage errorPage : getErrorPages()) &#123;</span><br><span class="line">    org.apache.tomcat.util.descriptor.web.<span class="type">ErrorPage</span> <span class="variable">tomcatErrorPage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.tomcat.util.descriptor.web.ErrorPage();</span><br><span class="line">    tomcatErrorPage.setLocation(errorPage.getPath());</span><br><span class="line">    tomcatErrorPage.setErrorCode(errorPage.getStatusCode());</span><br><span class="line">    tomcatErrorPage.setExceptionType(errorPage.getExceptionName());</span><br><span class="line">    context.addErrorPage(tomcatErrorPage);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (MimeMappings.Mapping mapping : getMimeMappings()) &#123;</span><br><span class="line">    context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());</span><br><span class="line">  &#125;</span><br><span class="line">  configureSession(context);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">DisableReferenceClearingContextCustomizer</span>().customize(context);</span><br><span class="line">  <span class="keyword">for</span> (TomcatContextCustomizer customizer : <span class="built_in">this</span>.tomcatContextCustomizers) &#123;</span><br><span class="line">    customizer.customize(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下 getSelfInitializer 方法的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> org.springframework.boot.web.servlet.ServletContextInitializer <span class="title function_">getSelfInitializer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//这里用了java8的方法引用的写法是对lambda表达式的简写，等价于(servletContext)-&gt;this.selfInitialize(servletContext)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>::selfInitialize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selfInitialize 方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selfInitialize</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  prepareWebApplicationContext(servletContext);</span><br><span class="line">  registerApplicationScope(servletContext);</span><br><span class="line">  WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);</span><br><span class="line">  <span class="keyword">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</span><br><span class="line">    <span class="comment">//这里的beans有我们关心的RegistrationBean的实例</span></span><br><span class="line">    beans.onStartup(servletContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getServletContextInitializerBeans 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ServletContextInitializer&gt; <span class="title function_">getServletContextInitializerBeans</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//ServletContextInitializerBeans继承了Collection，所以它实现了iterator()方法可以被遍历</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletContextInitializerBeans</span>(getBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletContextInitializerBeans 的 iterator()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;ServletContextInitializer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//sortedList的声明List&lt;ServletContextInitializer&gt; sortedList</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.sortedList.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletContextInitializerBeans 的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServletContextInitializerBeans</span><span class="params">(ListableBeanFactory beanFactory,</span></span><br><span class="line"><span class="params">    Class&lt;? extends ServletContextInitializer&gt;... initializerTypes)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.initializers = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">  <span class="built_in">this</span>.initializerTypes = (initializerTypes.length != <span class="number">0</span>) ? Arrays.asList(initializerTypes)</span><br><span class="line">      : Collections.singletonList(ServletContextInitializer.class);</span><br><span class="line">  <span class="comment">//将ServletContextInitializer的实例添加到MultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt; initializers中</span></span><br><span class="line">  addServletContextInitializerBeans(beanFactory);</span><br><span class="line">  addAdaptableBeans(beanFactory);</span><br><span class="line">   <span class="comment">//下面的逻辑最终会将initializers里面的ServletContextInitializer的实例保存到this.sortedList中</span></span><br><span class="line">  List&lt;ServletContextInitializer&gt; sortedInitializers = <span class="built_in">this</span>.initializers.values().stream()</span><br><span class="line">      .flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="built_in">this</span>.sortedList = Collections.unmodifiableList(sortedInitializers);</span><br><span class="line">  logMappings(<span class="built_in">this</span>.initializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addServletContextInitializerBeans 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addServletContextInitializerBeans</span><span class="params">(ListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">ServletContextInitializder</span>&gt; initializerType : <span class="built_in">this</span>.initializerTypes) &#123;</span><br><span class="line">    <span class="comment">//通过beanFactory获取在已经注册到Spring容器中的ServletContextInitializer实例，在MyConfig中注册的RegistrationBean在这里就可以获取到</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, ? <span class="keyword">extends</span> <span class="title class_">ServletContextInitializer</span>&gt; initializerBean : getOrderedBeansOfType(beanFactory,</span><br><span class="line">        initializerType)) &#123;</span><br><span class="line">      <span class="comment">//将ServletContextInitializer的实例添加到MultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt; initializers中</span></span><br><span class="line">      addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addServletContextInitializerBean(String beanName, ServletContextInitializer initializer,ListableBeanFactory beanFactory)的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addServletContextInitializerBean</span><span class="params">(String beanName, ServletContextInitializer initializer,</span></span><br><span class="line"><span class="params">    ListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ServletRegistrationBean) &#123;</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">source</span> <span class="operator">=</span> ((ServletRegistrationBean&lt;?&gt;) initializer).getServlet();</span><br><span class="line">    <span class="comment">//在这个方法里才真正将ServletContextInitializer的实例添加到MultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt; initializers中</span></span><br><span class="line">    addServletContextInitializerBean(Servlet.class, beanName, initializer, beanFactory, source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> FilterRegistrationBean) &#123;</span><br><span class="line">    <span class="type">Filter</span> <span class="variable">source</span> <span class="operator">=</span> ((FilterRegistrationBean&lt;?&gt;) initializer).getFilter();</span><br><span class="line">    addServletContextInitializerBean(Filter.class, beanName, initializer, beanFactory, source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> DelegatingFilterProxyRegistrationBean) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> ((DelegatingFilterProxyRegistrationBean) initializer).getTargetBeanName();</span><br><span class="line">    addServletContextInitializerBean(Filter.class, beanName, initializer, beanFactory, source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ServletListenerRegistrationBean) &#123;</span><br><span class="line">    <span class="type">EventListener</span> <span class="variable">source</span> <span class="operator">=</span> ((ServletListenerRegistrationBean&lt;?&gt;) initializer).getListener();</span><br><span class="line">    addServletContextInitializerBean(EventListener.class, beanName, initializer, beanFactory, source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    addServletContextInitializerBean(ServletContextInitializer.class, beanName, initializer, beanFactory,</span><br><span class="line">        initializer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addServletContextInitializerBean(Class&lt;?&gt; type, String beanName, ServletContextInitializer initializer,ListableBeanFactory beanFactory, Object source)的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addServletContextInitializerBean</span><span class="params">(Class&lt;?&gt; type, String beanName, ServletContextInitializer initializer,</span></span><br><span class="line"><span class="params">    ListableBeanFactory beanFactory, Object source)</span> &#123;</span><br><span class="line">  <span class="comment">//将ServletContextInitializer的实例添加到MultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt; initializers中</span></span><br><span class="line">  <span class="built_in">this</span>.initializers.add(type, initializer);</span><br><span class="line">  <span class="keyword">if</span> (source != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Mark the underlying source as seen in case it wraps an existing bean</span></span><br><span class="line">    <span class="built_in">this</span>.seen.add(source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resourceDescription</span> <span class="operator">=</span> getResourceDescription(beanName, beanFactory);</span><br><span class="line">    <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(initializer);</span><br><span class="line">    logger.trace(<span class="string">&quot;Added existing &quot;</span> + type.getSimpleName() + <span class="string">&quot; initializer bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;; order=&quot;</span></span><br><span class="line">        + order + <span class="string">&quot;, resource=&quot;</span> + resourceDescription);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最后在 ServletWebServerApplicationContext 中的 selfInitialize 方法里面通过 getServletContextInitializerBeans 获取到的是 ServletContextInitializerBeans 中保存了我们注册到 Spring 容器的 RegistrationBean 的实例的 sortedList，然后遍历 sortedList 从而调用这些 RegistrationBean 的实例的 onStartup 方法。（如果上面的流程解析看不懂，可以配合源码自己走一遍会更加清晰）</p>
<p>看下 RegistrationBean 的 onStartup 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> getDescription();</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    logger.info(StringUtils.capitalize(description) + <span class="string">&quot; was not registered (disabled)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用子类的register方法</span></span><br><span class="line">  register(description, servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DynamicRegistrationBean（FilterRegistrationBean 和 ServletRegistrationBean 的父类）实现了 register 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String description, ServletContext servletContext)</span> &#123;</span><br><span class="line">  <span class="comment">//调用子类的addRegistration方法</span></span><br><span class="line">  <span class="type">D</span> <span class="variable">registration</span> <span class="operator">=</span> addRegistration(description, servletContext);</span><br><span class="line">  <span class="keyword">if</span> (registration == <span class="literal">null</span>) &#123;</span><br><span class="line">    logger.info(StringUtils.capitalize(description) + <span class="string">&quot; was not registered (possibly already registered?)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  configure(registration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletRegistrationBean 的 addRegistration 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ServletRegistration.Dynamic <span class="title function_">addRegistration</span><span class="params">(String description, ServletContext servletContext)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getServletName();</span><br><span class="line">  <span class="comment">//这里的代码就很熟悉了，这里调用的就是servlet3.0提供的动态注册servlet的方法</span></span><br><span class="line">  <span class="keyword">return</span> servletContext.addServlet(name, <span class="built_in">this</span>.servlet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这就可以大概知道 SpringBoot 是如何加载 servlet 的了，filter 和 listener 也是如此。</p>
<h5 id="注册方式三：继承-ServletContextInitializer-实现-onStartup-方法"><a href="#注册方式三：继承-ServletContextInitializer-实现-onStartup-方法" class="headerlink" title="注册方式三：继承 ServletContextInitializer 实现 onStartup 方法"></a>注册方式三：继承 ServletContextInitializer 实现 onStartup 方法</h5><p>看完上面的分析我们还可以用第三种注册 servlet 的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomServletContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContextInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">JAR_HELLO_URL</span> <span class="operator">=</span> <span class="string">&quot;/custom&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建 customServlet...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">servlet</span> <span class="operator">=</span> servletContext.addServlet(</span><br><span class="line">                CustomServlet.class.getSimpleName(),</span><br><span class="line">                CustomServlet.class);</span><br><span class="line">        servlet.addMapping(JAR_HELLO_URL);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建 customFilter...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FilterRegistration.<span class="type">Dynamic</span> <span class="variable">filter</span> <span class="operator">=</span> servletContext.addFilter(</span><br><span class="line">                CustomFilter.class.getSimpleName(), CustomFilter.class);</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;DispatcherType&gt; dispatcherTypes = EnumSet.allOf(DispatcherType.class);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.REQUEST);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.FORWARD);</span><br><span class="line"></span><br><span class="line">        filter.addMappingForUrlPatterns(dispatcherTypes, <span class="literal">true</span>, JAR_HELLO_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这里提一下上面 ServletWebServerApplicationContext 中 createWebServer 的代码中的 getWebServerFactory()方法，它的作用是从 spring 容器中获取一个类型为 ServletWebServerFactory（TomcatServletWebServerFactory 是其子类）的工厂实例，而这个实例是通过 SpringBoot 的自动装配完成的（SpringBoot 的自动装配可以了解一下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ServletWebServerFactory <span class="title function_">getWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class="line">  String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class="line">        + <span class="string">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class="line">        + <span class="string">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从spring容器中获取一个类型为ServletWebServerFactory的工厂实例并且返回</span></span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">    //留意这个</span></span><br><span class="line"><span class="meta">    ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">    ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">    ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedTomcat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">        ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="line"><span class="params">        ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="line"><span class="params">        ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> &#123;</span><br><span class="line">      <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">      factory.getTomcatConnectorCustomizers()</span><br><span class="line">          .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">      factory.getTomcatContextCustomizers()</span><br><span class="line">          .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">      factory.getTomcatProtocolHandlerCustomizers()</span><br><span class="line">          .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>存在 web.xml 配置的 java web 项目，servlet3.0 的 java web 项目，springboot 内嵌容器的 java web 项目加载 servlet，filter，listener 的流程都是有所差异的，理解清楚这其中的原来，其实并不容易，至少得搞懂 servlet3.0 的规范，springboot 内嵌容器的加载流程等等前置逻辑。</p>
<p>最后还是要感谢<a href="https://www.cnkirito.moe/servlet-explore/#Initializer-%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA-TomcatStarter">这位大佬的文章</a>，我做的只是在他的基础上针对我自己再补充的笔记，文笔没有大佬的简洁，所以如果觉得说得太啰嗦看不懂建议去看这个大佬的文章，你会发觉你发现了新大陆。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 加行锁的规则</title>
    <url>/2024/06/05/mysql%E7%9A%84%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h3 id="MySQL-加行锁的规则"><a href="#MySQL-加行锁的规则" class="headerlink" title="MySQL 加行锁的规则"></a>MySQL 加行锁的规则</h3><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><p>MySQL 的版本是 8.0.30</p>
<p>这里说下这是我原来测试其它功能的表，如果觉得数据太多不好分析可以把数据弄个 4-5 条就可以了，初始化数据的 sql 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`  (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `test1` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `idx_name`(`name` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;name的唯一索引&#x27;</span>,</span><br><span class="line">  INDEX `idx_age`(`age` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;age的普通索引&#x27;</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">101</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb3 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb3_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;鲁班&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;诸葛亮&#x27;</span>, <span class="number">71</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;荆轲&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;安其拉&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;橘右京&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;宋江&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;钟馗&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;林冲&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;李逵&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;王莽&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李世民&#x27;</span>, <span class="number">54</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">13</span>, <span class="string">&#x27;刘备2&#x27;</span>, <span class="number">11</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">14</span>, <span class="string">&#x27;关羽&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">&#x27;王与&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="string">&#x27;秦叔宝&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">17</span>, <span class="string">&#x27;程咬金&#x27;</span>, <span class="number">65</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">18</span>, <span class="string">&#x27;嬴政&#x27;</span>, <span class="number">76</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">19</span>, <span class="string">&#x27;王建&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">&#x27;张郃&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">21</span>, <span class="string">&#x27;后裔&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">22</span>, <span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">23</span>, <span class="string">&#x27;猪八戒&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">24</span>, <span class="string">&#x27;沙和尚&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">25</span>, <span class="string">&#x27;乾隆&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">26</span>, <span class="string">&#x27;康熙&#x27;</span>, <span class="number">51</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">27</span>, <span class="string">&#x27;朱元璋&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">28</span>, <span class="string">&#x27;刘永&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">29</span>, <span class="string">&#x27;张伟&#x27;</span>, <span class="number">26</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">30</span>, <span class="string">&#x27;吕子乔&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">33</span>, <span class="string">&#x27;刘备&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">36</span>, <span class="string">&#x27;刘备4&#x27;</span>, <span class="number">13</span>, <span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="主键索引等值查询存在的记录"><a href="#主键索引等值查询存在的记录" class="headerlink" title="主键索引等值查询存在的记录"></a>主键索引等值查询存在的记录</h4><p>执行<code>SELECT * FROM student WHERE id = 36 LOCK IN SHARE MODE;</code>，之后执行 <code>SELECT * FROM performance_schema.data_locks;</code> 查看加锁情况（后面不会再重复查看加锁的语句）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/174aa138-bd2d-45a9-bb53-feaa7e04cf4a.jpg" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用主键索引等值查询，并且这条记录存在，只会对主键索引上的数据加 record 锁</p>
</blockquote>
<h4 id="主键索引等值查询不存在的记录"><a href="#主键索引等值查询不存在的记录" class="headerlink" title="主键索引等值查询不存在的记录"></a>主键索引等值查询不存在的记录</h4><p>执行<code>SELECT * FROM  student  WHERE id = 33 LOCK IN SHARE MODE;</code>加锁的情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/84e37a66-44e7-4564-9425-2b73533e6e3a.jpg" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用主键索引等值查询，并且这条记录不存在时，会在所在条件所在的间隙加 gap 锁（例子里面锁的区间是<code>(33,36)</code>）</p>
</blockquote>
<p>这里有个特殊情况就是如果数据落在表中最大值和 <code>supremum</code> 之间，比如执行<code>SELECT * FROM  student  WHERE id = 37 LOCK IN SHARE MODE;</code>，那么加锁的范围会是<code>(36,supremum]</code>，个人认为这里不用 gap 锁而是用 next-key 锁的原因是加锁的基本单位是 next-key 锁，只是根据情况降级到 record 锁和 gap 锁，但是在这里给 <code>supremum</code>加不加 record 锁没区别，所以就不需要锁降级</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/85ea15aa-262d-463b-b424-cc9730afaa00.jpg" alt="图片丢失"></p>
<h4 id="主键索引范围查询并且范围内存在记录"><a href="#主键索引范围查询并且范围内存在记录" class="headerlink" title="主键索引范围查询并且范围内存在记录"></a><span id="主键索引范围查询并且范围内存在记录">主键索引范围查询并且范围内存在记录</span></h4><p>执行<code>SELECT * FROM student WHERE id &gt; 29 AND id  &lt; 33  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/d08fcdb9-7685-497a-87c8-2ed9e0152752.jpg" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE id &gt;= 29 AND id  &lt; 33  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/fb605f6d-ef34-43dc-a1e4-2d0f2c97f648.jpg" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE id &gt; 29  AND id  &lt;= 33  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/a149d137-5ff6-4a71-a005-fef8ca419031.jpg" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE id &gt;= 29  AND id  &lt;= 33  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/f1b5671f-d3ac-4196-bf0d-904b92c0e380.jpg" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用主键索引范围查询，并且范围内存在记录，会对符合条件的记录加 next-key 或者 record 锁，对剩余未加锁的间隙的下一条记录加 gap 锁</p>
</blockquote>
<p>不过有一种特殊情况，执行<code>SELECT * FROM student WHERE id &gt; 29 AND id &lt;= 36  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/ab269093-242f-4402-806c-7578811caeb0.png" alt="图片丢失"></p>
<p>按理来说不应该给<code>(36,supremum]</code>加锁，</p>
<p>在《MySQL 实战 45 讲》中作者给行锁加锁规则总结了“两个原则”、“两个优化”和“一个 bug”（《MySQL 实战 45 讲》的作者说的是截止到当时最新的 MySQL 版本：5.x 系列&lt;=5.7.24，8.0 系列 &lt;=8.0.13），其中的一个 bug 就是<code>唯一索引上的范围查询会访问到不满足条件的第一个值为止</code>，也就是在上面的例子中虽然扫描到了<code>id=36</code>的索引，还要继续向后扫描，所以还要对<code>supremum</code>加 next-key 锁（虽然 MySQL 说在 8.0.18 版本已经修复这个<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-18.html#mysqld-8-0-18-bug">bug（关键词 Bug #29508068）</a>，但是对于一部分的查询还是有这个 bug，就如上面的例子的之后的非主键唯一索引和非唯一索引范围查询）。</p>
<h4 id="主键索引范围查询并且范围内不存在记录"><a href="#主键索引范围查询并且范围内不存在记录" class="headerlink" title="主键索引范围查询并且范围内不存在记录"></a>主键索引范围查询并且范围内不存在记录</h4><p>执行<code>SELECT * FROM student WHERE id &gt; 33 AND id &lt; 36  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/6d1288fa-2ceb-4711-9aaf-8584a3807370.png" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用主键索引范围查询，并且范围内不存在记录，会对查询条件所在范围的下一条记录加 gap 锁</p>
</blockquote>
<p>有一种特殊情况，执行<code>SELECT * FROM student WHERE id &gt; 36  LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/9491a311-71c6-4039-bca6-e7dd98b1777d.png" alt="图片丢失"></p>
<p>这里可以也是上面说的不需要降级所以给加的是 next-key 锁</p>
<h4 id="非主键唯一索引等值查询存在的记录"><a href="#非主键唯一索引等值查询存在的记录" class="headerlink" title="非主键唯一索引等值查询存在的记录"></a>非主键唯一索引等值查询存在的记录</h4><p>执行<code>SELECT * FROM  student WHERE name = &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/4490b333-318b-42ba-9fda-607d2b4ad766.png" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用非主键唯一索引等值查询，并且这条记录存在时，会对非主键唯一索引上查到的记录加 record 锁，还会给对应的主键索引的记录加上 record 锁</p>
</blockquote>
<p>还有特殊情况，执行<code>SELECT id, name FROM  student WHERE name = &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/576a14f9-3236-4720-95cb-7cf1792464ee.png" alt="图片丢失"></p>
<p>执行<code>SELECT id, name FROM  student WHERE name = &#39;刘备4&#39; FOR UPDATE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/1b0f1423-384d-49f0-be14-fce1180fe5c4.png" alt="图片丢失"></p>
<p>发现如果只是使用共享锁并且是索引覆盖查询是不需要对主键索引对于的记录加 record 锁的，但是排它锁查询是不管是否索引覆盖都给对应的主键索引加 record 锁</p>
<h4 id="非主键唯一索引等值查询不存在的记录"><a href="#非主键唯一索引等值查询不存在的记录" class="headerlink" title="非主键唯一索引等值查询不存在的记录"></a>非主键唯一索引等值查询不存在的记录</h4><p>执行<code>SELECT * FROM  student WHERE name = &#39;刘备3&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/1bc2fbd1-a28b-481c-ad09-f9d6c10c34c3.png" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用非主键唯一索引等值查询，并且这条记录不存在时，会对非主键唯一索引上查询条件所在间隙的下一条记录加 gap 锁</p>
</blockquote>
<p>又是锁不需要降级所以是加 next-key 锁的特殊情况，执行<code>SELECT * FROM  student  WHERE name = &#39;鲁班1&#39; LOCK IN SHARE MODE;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/47d81669-5483-470e-8fc7-3f2a21290ee0.png" alt="图片丢失"></p>
<h4 id="非主键唯一索引范围查询并且范围内存在记录"><a href="#非主键唯一索引范围查询并且范围内存在记录" class="headerlink" title="非主键唯一索引范围查询并且范围内存在记录"></a>非主键唯一索引范围查询并且范围内存在记录</h4><p>执行<code>SELECT * FROM student WHERE name &gt; &#39;刘备&#39; AND name  &lt; &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/6d95ab7e-29f5-4e16-8e3a-1c018a4a9ec1.png" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE name &gt;= &#39;刘备&#39; AND name  &lt; &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/07af74a7-f66a-4457-a55d-e0ad997f621e.png" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE name &gt; &#39;刘备&#39; AND name  &lt; &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/8356246f-0d6f-4052-bd98-3df6ed9f9169.png" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE name &gt;= &#39;刘备&#39; AND name  &lt;= &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/50752f4c-2867-4b53-b329-109900a34107.png" alt="图片丢失"></p>
<p>如果只是看非主键唯一索引加锁的情况会发现 bug</p>
<ol>
<li><code>name &lt; &#39;刘备4&#39;</code>原本应该锁的是<code>(刘备2,刘备4)</code>，但是现在多出了一个 record 锁，变成了<code>(刘备2,刘备4]</code></li>
<li><code>name &lt;= &#39;刘备4</code>原本应该锁的是<code>(刘备2,刘备4]</code>，但是现在多出来一个<code>(刘备4,刘永]</code></li>
<li><code>name &gt; &#39;刘备&#39;</code>原本应该就只是给<code>刘备</code>这条记录加 record 锁，但是多出来了一个 gap 锁，变成了<code>(关羽,刘备]</code></li>
</ol>
<p>这就是前面<a href="#主键索引范围查询并且范围内存在记录">主键索引范围查询并且范围内存在记录</a>中说的那个 bug 导致的</p>
<p>然后再看主键索引上的加锁情况发现主键索引上加锁是正常的</p>
<ol>
<li><code>name &lt; &#39;刘备4&#39;</code>在非主键唯一索引上加锁的范围是<code>(刘备2,刘备4]</code>，但是主键索引上并未对<code>刘备4</code>对应的记录 record 锁</li>
<li><code>name &lt;= &#39;刘备4</code>在非主键唯一索引上加锁的范围是<code>(刘备4,刘永]</code>，但是主键索引上并未对<code>刘永</code>对应的记录 record 锁</li>
</ol>
<blockquote>
<p>这里得出的结论是：使用非主键唯一索引范围查询，并且范围内存在记录，会对符合条件的记录加 next-key（上面的<code>name &gt; &#39;刘备&#39;</code>的 bug），会对不满足条件的第一个值记录加上 next-key 锁（上面的<code>name &lt; &#39;刘备4&#39;</code>和<code>name &lt;= &#39;刘备4</code>），在主键索引上，会对在查询范围内记录对应的主键索引上加 record 锁</p>
</blockquote>
<p>而且上面的这个现象还和你索引的排序有关，如果你执行把索引<code>idx_name</code>改成降序，再执行<code>SELECT * FROM student WHERE name &gt;= &#39;刘备&#39; AND name  &lt;= &#39;刘备4&#39; LOCK IN SHARE MODE;</code>，加锁就会变成下面这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/39a63219-66d9-4b2a-8daf-4c9aabf7418f.png" alt="图片丢失"></p>
<h4 id="非主键唯一索引范围查询并且范围内不存在记录"><a href="#非主键唯一索引范围查询并且范围内不存在记录" class="headerlink" title="非主键唯一索引范围查询并且范围内不存在记录"></a>非主键唯一索引范围查询并且范围内不存在记录</h4><p>执行<code>SELECT * FROM student WHERE name &gt; &#39;刘备1&#39; AND name  &lt; &#39;刘备2&#39; LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/f8826f9d-af4f-4a66-b2b7-d94701627f82.png" alt="图片丢失"></p>
<p>这里面加锁逻辑其实和上面的<code>非主键唯一索引范围查询并且范围内存在记录</code>加锁的一样的，都有那个 bug 的问题，区别就是查不到记录所以不会给主键索引加锁</p>
<blockquote>
<p>这里得出的结论是：使用非主键唯一索引范围查询，并且范围内不存在记录，会对查询条件所在间隙的下一条记录加 next-key 锁</p>
</blockquote>
<h4 id="非唯一索引等值查询存在的记录"><a href="#非唯一索引等值查询存在的记录" class="headerlink" title="非唯一索引等值查询存在的记录"></a>非唯一索引等值查询存在的记录</h4><p>执行<code>SELECT * FROM student  WHERE age = 12 LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/047e975d-6d32-43c6-a67c-3c922b07be34.png" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用非唯一索引等值查询，并且这条记录存在时，在非唯一索引上，会对符合查询条件的记录加 next-key 锁，会对不满足条件的第一个值记录加上 gap 锁，在主键索引上，对符合查询条件的记录在主键索引对应的位置上加 reocrd 锁</p>
</blockquote>
<h4 id="非唯一索引等值查询不存在的记录"><a href="#非唯一索引等值查询不存在的记录" class="headerlink" title="非唯一索引等值查询不存在的记录"></a>非唯一索引等值查询不存在的记录</h4><p>执行<code>SELECT * FROM student  WHERE age = 18 LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/9916c64d-cbe9-405e-b97d-115e19365c96.png" alt="图片丢失"></p>
<blockquote>
<p>这里得出的结论是：使用非唯一索引等值查询，并且这条记录不存在时，在非唯一索引上，会对符合查询条件所在间隙的下一条记录加 gap 锁</p>
</blockquote>
<p>这里也有那个锁没降级的情况，不在赘述了</p>
<h4 id="非唯一索引范围查询并且范围内存在记录"><a href="#非唯一索引范围查询并且范围内存在记录" class="headerlink" title="非唯一索引范围查询并且范围内存在记录"></a>非唯一索引范围查询并且范围内存在记录</h4><p>执行<code>SELECT * FROM student WHERE age &gt;= 12 AND age  &lt; 13   LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/cdd437a0-a423-48b0-9610-44a2dd404680.png" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE age &gt; 12 AND age  &lt;= 13   LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/79f05fb8-1ef3-47c7-85ef-26a132633e81.png" alt="图片丢失"></p>
<p>执行<code>SELECT * FROM student WHERE age &gt;= 12 AND age  &lt;= 13   LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/fccc49cd-e996-4ffe-bc23-55782c25618f.png" alt="图片丢失"></p>
<p>如果只是看非唯一索引加锁的情况会发现 bug</p>
<ol>
<li><code>age &lt; 13</code>原本应该锁的是<code>(12,13)</code>，但是现在多出了一个 record 锁变成了<code>(12,13]</code></li>
<li><code>age &lt;= 13</code> 原本应该锁的是<code>(12,13]</code>，但是现在多出了一个 next-key 锁<code>(13,17]</code></li>
</ol>
<p>这就是前面<a href="#主键索引范围查询并且范围内存在记录">主键索引范围查询并且范围内存在记录</a>中说的那个 bug 导致的</p>
<p>然后再看主键索引上的加锁情况发现主键索引上加锁是正常的</p>
<ol>
<li><code>age &lt; 13&#39;</code>在非唯一索引上加锁的范围是<code>(12,13]</code>，但是主键索引上并未对<code>13</code>对应的记录 record 锁</li>
<li><code>age &lt;= 13</code>在非唯一索引上加锁的范围是<code>(13,17]</code>，但是主键索引上并未对<code>17</code>对应的记录 record 锁</li>
</ol>
<blockquote>
<p>这里得出的结论是：使用非唯一索引范围查询，并且范围内存在记录，会对符合条件的记录加 next-key，会对不满足条件的第一个值记录加上 next-key 锁（上面的<code>age &lt; 13&#39;</code>和<code>age &lt;= 13</code>），在主键索引上，会对在查询范围内记录对应的主键索引上加 record 锁</p>
</blockquote>
<p>不过这里要说一下<code>age &gt; 12</code>的情况，因为 age 是 12 的有多条，但是这里<code>(12,13]</code>的 12 这条记录对应的是 id 最大的那条，这里对应的就是 id=28 的这条，原因也很简单因为我的索引是升序排序的，如果相同的情况下会根据 id 再升序排序，如果你这里把索引的排序改成降序，那么索引值相同的情况下还是会根据 id 升序排序，下面把 age 的排序改成降序，执行<code>SELECT * FROM student WHERE age &gt; 12 AND age  &lt;= 13   LOCK IN SHARE MODE;</code>后加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/c49389f4-961f-4b0c-9439-bbfe60a26f11.png" alt="图片丢失"></p>
<p>如果是 age 相同的情况下是按照 id 降序的话，这里应该锁显示的 LOCK_DATA 显示的是<code>12,28</code></p>
<p>所以根据上面的情况可以发现<code>age &gt; 12</code>并且索引升序的情况下可以插入 age=12 的记录只是要求 id 小于最大的值就行，在这里就是 id 小于 28，<code>age &lt; 13</code>也是一样的逻辑只是变成 id 要大于最小值</p>
<h4 id="非唯一索引范围查询并且范围内不存在记录"><a href="#非唯一索引范围查询并且范围内不存在记录" class="headerlink" title="非唯一索引范围查询并且范围内不存在记录"></a>非唯一索引范围查询并且范围内不存在记录</h4><p>执行<code>SELECT * FROM student WHERE age &gt; 12 AND age  &lt; 13   LOCK IN SHARE MODE;</code>，加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/94efc14e-425a-47b2-888d-61b164c33474.png" alt="图片丢失"></p>
<p>这里面加锁逻辑其实和上面的<code>非唯一索引范围查询并且范围内存在记录</code>加锁的一样的，都有那个 bug 的问题，区别就是查不到记录所以不会给主键索引加锁</p>
<blockquote>
<p>这里得出的结论是：使用非唯一索引范围查询，并且范围内不存在记录，会对查询条件所在间隙的下一条记录加 next-key 锁</p>
</blockquote>
<h4 id="不使用索引查询"><a href="#不使用索引查询" class="headerlink" title="不使用索引查询"></a>不使用索引查询</h4><p>分别执行</p>
<p><code>SELECT id,name FROM student WHERE test1 = 2 LOCK IN SHARE MODE;</code></p>
<p><code>SELECT id,name FROM student WHERE test1 &gt; 2 LOCK IN SHARE MODE;</code></p>
<p>加锁情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/45ecd17d-db88-41d8-8575-70912179079f.png" alt="图片丢失"></p>
<p>这里图片截不全，表中每一条记录包括最大界限伪记录 supremum 都加了锁 next-key 锁</p>
<blockquote>
<p>这里得出的结论是：不使用索引查询时，无论是等值查询还是范围查询，无论是否存在查询结果，都会对表中所有的记录加 next-key 锁，也就是我们常说的“锁表”</p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>好烦</title>
    <url>/2019/12/05/test/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分类1</category>
        <category>分类4</category>
        <category>分类2</category>
        <category>分类3</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty启动源码分析</title>
    <url>/2025/04/21/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Netty-启动源码分析"><a href="#Netty-启动源码分析" class="headerlink" title="Netty 启动源码分析"></a>Netty 启动源码分析</h2><h3 id="ServerBootstrap-的启动"><a href="#ServerBootstrap-的启动" class="headerlink" title="ServerBootstrap 的启动"></a>ServerBootstrap 的启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//主要关注的是bind方法的底层逻辑</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8000</span>).sync();</span><br><span class="line">        sync.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;operationComplete&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sync.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>从<code>bind</code> 方法进入调试最终会进入到 AbstractBootstrap 里的<code>doBind</code>方法，其中有两个点：</p>
<ul>
<li><p>AbstractBootstrap.initAndRegister：初始化 ServerSocketChannel 并将 ServerSocketChannel 注册到 selector 的方法</p>
</li>
<li><p>AbstractBootstrap.doBind0：ServerSocketChannel 绑定端口号的方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">        <span class="comment">//重点关注点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">            <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line">                        <span class="comment">//重点关注点</span></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractBootstrap-initAndRegister"><a href="#AbstractBootstrap-initAndRegister" class="headerlink" title="AbstractBootstrap.initAndRegister"></a>AbstractBootstrap.initAndRegister</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span></span><br><span class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">    <span class="comment">//    added to the event loop&#x27;s task queue for later execution.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span></span><br><span class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会调用 ChannelFactory 工厂类的方法得到一个 Channel，相当于 NIO 中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<p>然后进入 init 方法，关键点在于利用刚刚得到的 channel 对象，创建了一个 pipeline，并且添加了一个 ChannelInitializer 处理器，监听初始化事件，在初始化事件中，使用 eventLoop 所在的 NIO 线程，提交一个任务，向 pipeline 中新增一个 ServerBootstrapAcceptor 用于处理新连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">        setAttributes(channel, newAttributesArray());</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = newOptionsArray(childOptions);</span><br><span class="line">        <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = newAttributesArray(childAttrs);</span><br><span class="line"></span><br><span class="line">        p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>外层的<code>p.addLast(new ChannelInitializer&lt;Channel&gt;()</code>添加进去的 ChannelInitializer 中的 initChannel 方法要在 AbstractUnsafe 的 register0 中 pipeline.invokeHandlerAddedIfNeeded();方法调用时被执行</p>
<p>扩展：里面的<code>pipeline.addLast(handler)</code> 添加的就是我们自己配置的 ServerBootstrap.handler 里面的 ChannelInitializer，但是这里的 initChannel 方法就直接执行，因为 DefaultChannelPipeline 中的 registered 已经变为了 true，这个值也是因为前面调用了 invokeHandlerAddedIfNeeded 最终在 DefaultChannelPipeline 中的 callHandlerAddedForAllHandlers 中变为了 true</p>
<p>之后<code>config().group().register(channel)</code>这段代码的的调用流程图大致如下：<span id="config_group_register"> </span></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/07d6ffe4-687f-49c6-9e60-f0cf0094c508.png" alt="图片丢失" title="config().group().register(channel)调用流程"></p>
<p>AbstractUnsafe.register(EventLoop eventLoop, final ChannelPromise promise)的主要是使用 eventLoop.inEventLoop()判断当前线程是否是 eventLoop 的线程，如果在当前线程直接执行 register0(promise)，否则交给 eventLoop 起一个新的线程执行</p>
<p>在这里现然不是，因为从上面的流程图可以看出创建新的线程是在 SingleThreadEventExecutor.doStartThread()方法里面实现的，具体是在 ThreadPerTaskExecutor.execute(Runnable command)中实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">    register0(promise);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(</span><br><span class="line">                <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                AbstractChannel.<span class="built_in">this</span>, t);</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/01613df2-565a-402c-a0ff-0712c79585f4.jpg" alt="图片丢失" title="SingleThreadEventExecutor.doStartThread()"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/233abda2-83b3-41ba-96d4-d5737df5da47.jpg" alt="图片丢失" title="ThreadPerTaskExecutor.execute(Runnable command)"></p>
<p>SingleThreadEventExecutor.execute(Runnable task, boolean immediate)主要将任务添加到 taskQueue 中，并且判断当前线程是否是 eventLoop 的线程，如果不是就开启一个新的线程去执行 taskQueue 中的任务，这里添加到 taskQueue 中的任务是在 AbstractUnsafe.register 方法中匿名实现的，执行 register0(promise)</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/fcb5f1a8-9744-4339-97be-5713baecf2e1.png" alt="图片丢失" title="SingleThreadEventExecutor.executeRunnable task, boolean immediate)"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/b104e4fd-08f2-4b01-ae74-a6cdf5fa7a67.jpg" alt="图片丢失" title="register0(promise)"></p>
<p>之后就是就是在 eventLoop 中线程的执行的流程逻辑了，执行逻辑的流程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/5542526a-bf42-4c32-b216-c5df7c96434c.jpg" alt="图片丢失" title="eventLoop中线程的执行流程"></p>
<p>在 SingleThreadEventExecutor.doStartThread()启动一个新线程并将线程赋值给变量 thread，在这之后在该线程内 eventLoop.inEventLoop()返回的都是 true 了</p>
<p>SingleThreadEventExecutor.runAllTasks(long timeoutNanos)将 taskQueue 的任务取出来并执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/2ccf803a-b8c0-4bb6-b479-c21260ac17be.jpg" alt="图片丢失" title="SingleThreadEventExecutor.runAllTasks(long timeoutNanos)"></p>
<p>之后就是 register0(ChannelPromise promise)的执行流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/32907cd4-3e95-4473-a560-b34bedd93479.png" alt="图片丢失" title="register0(ChannelPromise promise)的执行流程"></p>
<ul>
<li>AbstractNioChannel.doRegister()将 NIO 的 ServerSocketChannel 注册到 Selector 中</li>
<li>DefaultChannelPipeline.invokeHandlerAddedIfNeeded() 执行 pendingHandlerCallbackHead 中的任务</li>
<li>AbstractUnsafe.safeSetSuccess(ChannelPromise promise) 唤醒因为 ChannelPromise（继承了 ChannelFuture）等待的线程，并且执行相应的 listeners</li>
</ul>
<h5 id="AbstractNioChannel-doRegister"><a href="#AbstractNioChannel-doRegister" class="headerlink" title="AbstractNioChannel.doRegister"></a>AbstractNioChannel.doRegister</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</code>将 NIO 的 ServerSocketChannel 注册到 Selector 中，并且将当前的 NioServerSocketChannel 作为 attachment 加入到 NIO 的 SelectionKey 中，相当于 NIO 里面的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, attach);</span><br></pre></td></tr></table></figure>
<h5 id="DefaultChannelPipeline-invokeHandlerAddedIfNeeded"><a href="#DefaultChannelPipeline-invokeHandlerAddedIfNeeded" class="headerlink" title="DefaultChannelPipeline.invokeHandlerAddedIfNeeded"></a>DefaultChannelPipeline.invokeHandlerAddedIfNeeded</h5><p>DefaultChannelPipeline.invokeHandlerAddedIfNeeded() 会在 callHandlerAddedForAllHandlers()执行 pendingHandlerCallbackHead 中的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invokeHandlerAddedIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">        <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callHandlerAddedForAllHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This Channel itself was registered.</span></span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        pendingHandlerCallbackHead = <span class="built_in">this</span>.pendingHandlerCallbackHead;</span><br><span class="line">        <span class="comment">// Null out so it can be GC&#x27;ed.</span></span><br><span class="line">        <span class="built_in">this</span>.pendingHandlerCallbackHead = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while</span></span><br><span class="line">    <span class="comment">// holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside</span></span><br><span class="line">    <span class="comment">// the EventLoop.</span></span><br><span class="line">    <span class="type">PendingHandlerCallback</span> <span class="variable">task</span> <span class="operator">=</span> pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里 pendingHandlerCallbackHead 中就有一个在前面 ServerBootstrap.init(Channel channel)中通过<code>p.addLast(new ChannelInitializer&lt;Channel&gt;()</code>添加进去的 PendingHandlerAddedTask</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="type">boolean</span> added)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">    <span class="type">PendingHandlerCallback</span> <span class="variable">task</span> <span class="operator">=</span> added ? <span class="keyword">new</span> <span class="title class_">PendingHandlerAddedTask</span>(ctx) : <span class="keyword">new</span> <span class="title class_">PendingHandlerRemovedTask</span>(ctx);</span><br><span class="line">    <span class="type">PendingHandlerCallback</span> <span class="variable">pending</span> <span class="operator">=</span> pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="literal">null</span>) &#123;</span><br><span class="line">        pendingHandlerCallbackHead = task;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the tail of the linked-list.</span></span><br><span class="line">        <span class="keyword">while</span> (pending.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pending = pending.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pending.next = task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PendingHandlerAddedTask.execute()的执行流程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/94a554e6-d3b3-4e8a-a8be-27e597fed959.jpg" alt="图片丢失" title="PendingHandlerAddedTask.execute()的执行流程"></p>
<p>最终调用的是 ServerBootstrap 中匿名实现的 ChannelInitializer.initChannel(C ch)，到了这里回到前面说的<code>p.addLast(new ChannelInitializer&lt;Channel&gt;()</code>添加进去的 ChannelInitializer，执行它的 initChannel(final Channel ch)将我们在 ServerBootstrap.handler 里面的 ChannelInitializer 添加到 DefaultChannelPipeline 中的 AbstractChannelHandlerContext 的调用链中，但是和前面 addLast 不同的是这里因为在 DefaultChannelPipeline.callHandlerAddedForAllHandlers()已经将 registered 变为了 true，直接就调用 callHandlerAdded0(final AbstractChannelHandlerContext ctx)，后面的逻辑就和上面说的一样</p>
<p>在 ChannelInitializer.initChannel(ChannelHandlerContext ctx)中执行完 initChannel(C ch)后会调用 pipeline.remove(this)，最终在 DefaultChannelPipeline.atomicRemoveFromHandlerList(AbstractChannelHandlerContext ctx)将 ChannelInitializer 从 DefaultChannelPipeline 中 AbstractChannelHandlerContext 调用链中移除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">atomicRemoveFromHandlerList</span><span class="params">(AbstractChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">prev</span> <span class="operator">=</span> ctx.prev;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> ctx.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AbstractUnsafe-safeSetSuccess"><a href="#AbstractUnsafe-safeSetSuccess" class="headerlink" title="AbstractUnsafe.safeSetSuccess"></a><span id="AbstractUnsafe_safeSetSuccess">AbstractUnsafe.safeSetSuccess</span></h5><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/c829ec16-b9d4-4511-b95a-3ae57f89fa33.png" alt="图片丢失" title="AbstractUnsafe.safeSetSuccess的调用逻辑"></p>
<p>RESULT_UPDATER.compareAndSet(this, null, objResult) || RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)是使用 AtomicReferenceFieldUpdater.compareAndSet(T obj, V expect, V update)将 DefaultPromise 的 result 设置为 DefaultPromise.SUCCESS（因为 setValue0(result == null ? SUCCESS : result)）</p>
<p>DefaultPromise.checkNotifyWaiters()判断 waiters 的数量是否大于 0，如果大于 0 就唤醒等待的线程（ChannelPromise.sync()中会调用 ChannelPromise.ChannelPromise 增加 waiters 和调用 Object.wait()等待唤醒）并且有 listeners 的话会返回 true，之后就会调用对应的 GenericFutureListener</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/3ed6d1b3-32ca-46a7-bef1-c8dd5be6f4a9.jpg" alt="图片丢失" title="DefaultPromise.checkNotifyWaiters()代码逻辑"></p>
<p>DefaultPromise.notifyListeners()最终会调用 DefaultChannelPromise.addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener)添加进去的 GenericFutureListener</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/72083d04-e8d0-49ca-8eee-bf4b9367d80e.png" alt="图片丢失" title="DefaultPromise.notifyListeners()的调用逻辑"></p>
<p>需要说明一下的是 DefaultPromise.notifyListenersNow()的代码都会 NIO 的线程里面执行，因为其判断逻辑是如果当前线程是 NIO 线程就直接用当前线程执行，如果不是就将其作为任务加入到 taskQueue 中等待执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/9334db1f-3315-4544-8e6f-2fe935f6a40c.png" alt="图片丢失" title="DefaultPromise.notifyListeners()代码逻辑"></p>
<h4 id="AbstractBootstrap-doBind0"><a href="#AbstractBootstrap-doBind0" class="headerlink" title="AbstractBootstrap.doBind0"></a>AbstractBootstrap.doBind0</h4><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/8cb4a2e6-9599-41f7-b672-163e739ede55.png" alt="图片丢失" title="Channel、ChannelPipeline、ChannelHandlerContext、ChannelHandler之间的关系"></p>
<p>inbound 事件会从 head 开始往后找到最后一个 inboundHandler 并执行事件相关方法，outbound 事件会从 tail 开始往前找到最后一个 outboundHandler 并执行事件相关方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/e6972527-8db1-4347-83df-725d807871dd.png" alt="图片丢失" title="doBind0的执行流程"></p>
<p>根据前面 outbound 事件的调用链逻辑发现最终会执行到 HeadContext.bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)，继续追下去找到 AbstractUnsafe.bind(final SocketAddress localAddress, final ChannelPromise promise)，里面有两个需要注意的点</p>
<ul>
<li>NioServerSocketChannel.doBind(SocketAddress localAddress) 将 ServerSocketChannel 绑定到具体某个端口</li>
<li>DefaultChannelPipeline.fireChannelActive()触发 inbound 事件调用对应 inboundHandler 对应的 channelActive(ChannelHandlerContext ctx)方法</li>
<li>AbstractUnsafe.safeSetSuccess(ChannelPromise promise) 唤醒因为 ChannelPromise（继承了 ChannelFuture）等待的线程，并且执行相应的 listeners</li>
</ul>
<h5 id="NioServerSocketChannel-doBind"><a href="#NioServerSocketChannel-doBind" class="headerlink" title="NioServerSocketChannel.doBind"></a>NioServerSocketChannel.doBind</h5><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/a82f0b00-1e46-4c76-94b3-a0c43b051da9.jpg" alt="图片丢失" title="NioServerSocketChannel.doBind(SocketAddress localAddress) 代码实现"></p>
<p>这里用的是 java8 所以会执行到 javaChannel().bind(localAddress, config.getBacklosg())，这里这些的代码就是 NIO 里面的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br></pre></td></tr></table></figure>
<h5 id="DefaultChannelPipeline-fireChannelActive"><a href="#DefaultChannelPipeline-fireChannelActive" class="headerlink" title="DefaultChannelPipeline.fireChannelActive"></a>DefaultChannelPipeline.fireChannelActive</h5><p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/b212653b-515c-489c-a271-f9325c0d9157.png" alt="图片丢失s" title="DefaultChannelPipeline.fireChannelActive()被调用的相关代码逻辑"></p>
<p>从<code>!wasActive &amp;&amp; isActive()</code>这段代码看出 DefaultChannelPipeline.fireChannelActive()这个方法要在 channel 第一次 active 的情况下才会执行，isActive()最终就是判断 ServerSocketChannel 的 open 是否为 true 并且 ServerSocketChannel 对应的 ServerSocketAdaptor.isBound()是否为 true，这里 open 默认为 true，区别是两次 isActive()的调用分别在 javaChannel().bind(localAddress, config.getBacklosg())的前后</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/5bd17d65-8a1b-4ec8-b99e-e3327066f18e.jpg" alt="图片丢失" title="NioServerSocketChannel.isActive()代码实现"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/41d0b326-8c9c-4f45-b960-a00cd4b5c1a5.jpg" alt="图片丢失" title="AbstractInterruptibleChannel.isOpen()"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/98f48d62-3e09-42e4-bdf8-3048667c98c8.jpg" alt="图片丢失" title="AbstractInterruptibleChannel初始open值"></p>
<p>不过这里不是直接调用而是通过 AbstractUnsafe.invokeLater(Runnable task)，将任务加入到 taskQueue，之后在 NIO 线程中 SingleThreadEventExecutor.runAllTasks 执行</p>
<p>DefaultChannelPipeline.fireChannelActive()的执行逻辑就是前面说的 inbound 事件调用链，执行所有 inboundHandler 对应的 channelActive(ChannelHandlerContext ctx)方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/19ef81e9-9b85-4c36-958c-676885363c0c.png" alt="图片丢失" title="DefaultChannelPipeline.fireChannelActive()的执行流程"></p>
<p>不过需要注意的是 HeadContext 的 channelActive(ChannelHandlerContext ctx)中会调用 HeadContext.readIfIsAutoRead()，最终会调用到 AbstractNioChannel.doBeginRead()，其中<code>selectionKey.interestOps(interestOps | readInterestOp)</code>（这里的 readInterestOp 就是 SelectionKey.OP_ACCEPT）相当于 NIO 中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/ac121e1a-dd3c-4926-a988-2bfa2a4e0d09.png" alt="图片丢失" title="HeadContext.readIfIsAutoRead()的执行流程"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/f5ac6822-b85e-41ef-868e-834ee4d73ccf.jpg" alt="图片丢失" title="AbstractNioChannel.doBeginRead()代码逻辑"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/317676db-44c4-46e5-b7b4-da88eb160196.jpg" alt="图片丢失" title="NioServerSocketChannel中指定readInterestOp为SelectionKey.OP_ACCEPT"></p>
<h5 id="AbstractUnsafe-safeSetSuccess-1"><a href="#AbstractUnsafe-safeSetSuccess-1" class="headerlink" title="AbstractUnsafe.safeSetSuccess"></a>AbstractUnsafe.safeSetSuccess</h5><p><a href="#AbstractUnsafe_safeSetSuccess">前面已经介绍了</a>不再赘述</p>
<h3 id="ServerBootstrap-启动中一些细节问题"><a href="#ServerBootstrap-启动中一些细节问题" class="headerlink" title="ServerBootstrap 启动中一些细节问题"></a>ServerBootstrap 启动中一些细节问题</h3><h4 id="EventLoop-何时被创建"><a href="#EventLoop-何时被创建" class="headerlink" title="EventLoop 何时被创建"></a>EventLoop 何时被创建</h4><p>在 NioEventLoopGroup(int nThreads) 构造器一路追踪，最后 MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object… args) 中调用 NioEventLoopGroup.newChild(Executor executor, Object… args)创建 EventLoop</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/d58273cb-a34d-4a64-a029-68d1490f0903.png" alt="图片丢失" title="EventLoop被创建的调用链"></p>
<p>在中间省略的过程中指定了一些 NioEventLoopGroup 和 NioEventLoop 的一些属性值，大致如下：</p>
<ul>
<li>selectorProvider 是 NIO 中 Selector 的提供者在<code>Selector.open()</code>和<code>ServerSocketChannel.open()</code>中都有用到，默认是通过<code>SelectorProvider.provider()</code>获取</li>
<li>nThreads 是指定 NioEventLoopGroup 中有多少个 NioEventLoop，如果没有指定默认是使用<code>MultithreadEventLoopGroup.DEFAULT_EVENT_LOOP_THREADS</code>，这个默认是当前系统可使用的处理器数量乘以 2</li>
<li>executor 每个 NioEventLoop 在 doStartThread()中创建线程的时候使用的 Executor，默认是<code>ThreadExecutorMap.apply(final Executor executor, final EventExecutor evntExecutor)</code>的匿名实现，其中参数中的 executor 默认是 ThreadPerTaskExecutor</li>
<li>rejectedExecutionHandler 是 NioEventLoop 中待执行任务 taskQueue 中任务超过一定数量之后的决策策略</li>
<li>maxPendingTasks 指定 taskQueue 中最多可以存放的待执行任务数，通过设置<code>SingleThreadEventExecutor.DEFAULT_MAX_PENDING_EXECUTOR_TASKS</code>指定，默认是 16</li>
<li>selectStrategyFactory 默认是 DefaultSelectStrategyFactory，构建出的 DefaultSelectStrategy 中的<code>calculateStrategy(IntSupplier selectSupplier, boolean hasTasks)</code>会在 NioEventLoop 中的 run()方法中用到<span id="DefaultSelectStrategy_calculateStrategy"> </span></li>
</ul>
<h4 id="提交普通任务时是否会结束-select-阻塞"><a href="#提交普通任务时是否会结束-select-阻塞" class="headerlink" title="提交普通任务时是否会结束 select 阻塞"></a>提交普通任务时是否会结束 select 阻塞</h4><p>select 方法默认阻塞的时间是获取定时任务队列 AbstractScheduledEventExecutor.scheduledTaskQueue 中的第一个任务的 deadlineNanos，如果定时任务队列中没有任务那么 curDeadlineNanos 就是 NioEventLoop.NONE，最终在 select 方法中会一直阻塞，直到被唤醒</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/47d0637c-8660-46c5-87de-44cb53590393.jpg" alt="图片丢失" title="NioEventLoop.run()方法的SelectStrategy.SELECT分支"></p>
<p>前面<a href="#config_group_register">config().group().register(channel)调用流程那张图</a>中的 SingleThreadEventExecutor.execute(Runnable task)就是提交提交任务的方法，该法会继续调用 SingleThreadEventExecutor.execute(Runnable task, boolean immediate) ,其中 immediate 主要取决于任务是否不是 LazyRunnable，后面的 wakesUpForTask(task)在 SingleThreadEventExecutor 固定为 true</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/7598669f-10ed-417f-89b8-6d648f53eff7.png" alt="图片丢失" title="immediate的判断逻辑"></p>
<p>SingleThreadEventExecutor.execute(Runnable task, boolean immediate)中的 addTaskWakesUp 在 NioEventLoop 中默认就是 false，所以其实主要还是取决于前面说的 immediate 这个值</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/a6bd21e8-a6f8-49ca-9ac1-7b86a7a6bfc6.png" alt="图片丢失" title="SingleThreadEventExecutor.execute(Runnable task, boolean immediate)中的 wakeup"></p>
<p>只有不是当前 NIO 线程并且 nextWakeupNanos 的值不是 AWAKE，才会调用 selector.wakeup()唤醒，所以多个线程多次调用 NioEventLoop.wakeup(boolean inEventLoop)下只有第一个线程会起到唤醒的效果，其他线程的调用都是无效操作浪费性能</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/6e42ee0b-2c5c-4cc8-980a-ead20fc4c808.jpg" alt="图片丢失" title="NioEventLoop.wakeup(boolean inEventLoop)代码逻辑"></p>
<p>扩展说下 addTaskWakesUp 的作用就是用于判断是否只要添加了任务就可以直接被唤醒，在 NioEventLoop 中它默认为 false 是因为这里线程的阻塞是因为调用了 Selector 的 select 方法，而 DefaultEventLoop 是任务队列中没有任务所以阻塞（在 SingleThreadEventExecutor.takeTask()中执行了 taskQueue.take()阻塞），只需要提交任务进去就会唤醒，所以 DefaultEventLoop 中 addTaskWakesUp 是 true</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/46bc7c97-5895-47c2-9c66-eb086364c57c.jpg" alt="图片丢失" title="DefaultEventLoop.run()"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/cffbfc43-5737-4e52-aa79-1c1463ebc714.jpg" alt="图片丢失" title="SingleThreadEventExecutor.takeTask()"></p>
<h4 id="NioEventLoop-run-中的循环何时才会进入-SelectStrategy-SELECT-分支"><a href="#NioEventLoop-run-中的循环何时才会进入-SelectStrategy-SELECT-分支" class="headerlink" title="NioEventLoop.run()中的循环何时才会进入 SelectStrategy.SELECT 分支"></a>NioEventLoop.run()中的循环何时才会进入 SelectStrategy.SELECT 分支</h4><p>前面提到<a href="#DefaultSelectStrategy_calculateStrategy">DefaultSelectStrategy.calculateStrategy(IntSupplier selectSupplier, boolean hasTasks)</a>在这里就是用于获取循环需要进入哪个分支的判断依据，如果任务队列中没有任务就会进入 SelectStrategy.SELECT 分支，如果任务队列中有任务就会调用 selectSupplier.get()（这里 selectSupplier 是在 NioEventLoop 的匿名实现），最终调用的的是 Selector.selectNow()查看当 selector 上是否有 IO 事件，有则一并返回</p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/0204d44d-19cf-483d-b4e9-323f8eb51eae.jpg" alt="图片丢失" title="NioEventLoop.run()中的循环"></p>
<p><img src="https://cdn.jsdelivr.net/gh/OUZHANBO/pics/img/1b6759e5-5f34-4271-8954-f3a956894539.jpg" alt="图片丢失" title="DefaultSelectStrategy.calculateStrategy(IntSupplier selectSupplier, boolean hasTasks)逻辑"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字声明的变量的加载问题</title>
    <url>/2020/01/20/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="static-关键字声明的变量的加载机制"><a href="#static-关键字声明的变量的加载机制" class="headerlink" title="static 关键字声明的变量的加载机制"></a>static 关键字声明的变量的加载机制</h3><p>前段时间在学习单例模式的时候遇到一种写法事用静态内部类来实现的，发现自己不是很懂静态内部类的加载时序，后来衍生到了 static 关键字修饰的变量方法都不是很懂，在网上找了一些文章看了下，大概明白他们的加载的机制和时序，下面来说下。之前我知道类的静态变量会在类被加载的时候初始化，但是类什么时候会被加载呢，这个我之前都没有考虑过。以下是我觉得我平时用得比较多的类加载方式：</p>
<p>​ 1.调用类的静态变量或者静态方法</p>
<p>​ 2.new 一个类的对象</p>
<p>​ 3.Class.forName 动态加载类</p>
<p>下面用代码测试一下第一种情况，在 Main 这个运行类型中的 main 入口方法中调用 Example 类的静态方法 staticField4，这样就会加载 Example 类并且先初始化这个类中的静态变量，静态代码块和静态代码的运行顺序取决于代码的编写顺序，然后再执行 main 方法，测试代码如下：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticField</span><span class="params">(String string)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StaticField staticField3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法staticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Example.staticMethod1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">静态方法staticMethod1被执行</span><br></pre></td></tr></table></figure>
<p>从结果可以看出这个是先执行静态变量的初始化然后才执行静态方法，静态变量的初始化执行顺序取决代码的顺序并且静态代码块中需要初始化的静态变量可以写在静态代码块之后并且该静态变量可以声明为 final，但是不可以在静态代码块中对 final 声明的静态变量初始化两次，这样编译不会通过，实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_">ExampleParent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">        <span class="comment">//编译会不通过，说staticField3已经被赋值</span></span><br><span class="line">        <span class="comment">//staticField3 = new StaticField(&quot;静态代码块中静态变量staticField3被初始化&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StaticField staticField3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里可能还有一个问题，如果在 main 中不调用 Example 的静态方法而是直接调用其中一个静态变量就只会初始化那个被调用的静态变量呢，下面修改 Main 的 main 方法来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.staticField2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>可以看到初始化静态变量的动作并没有发生任何的改变，还是和之前一样按顺序的将所有的静态变量初始化了。另外两种情况就在这里简单演示一下，结果都基本一样</p>
<p>第二种情况，new Example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br></pre></td></tr></table></figure>
<p>第三种情况，Class.forName 动态加载类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;Example&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br></pre></td></tr></table></figure>
<p>有一种很迷惑我的情况是不可以的，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br></pre></td></tr></table></figure>
<p>这种情况并没有加载 Example 类，这个很迷惑人，需要注意。</p>
<h3 id="父子类-static-关键字修饰的变量的加载顺序"><a href="#父子类-static-关键字修饰的变量的加载顺序" class="headerlink" title="父子类 static 关键字修饰的变量的加载顺序"></a>父子类 static 关键字修饰的变量的加载顺序</h3><p>如果出现集成的情况，那么会先执行父类的静态代内容（静态变量和静态代码块），然后再执行子类的静态内容（静态变量和静态代码块）</p>
<p>认证代码如下：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticField</span><span class="params">(String string)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParentExample：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">StaticField</span> <span class="variable">parentStaticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;父类的静态变量parentStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField parentStaticField2;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            parentStaticField2 = <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;父类的静态代码块中静态变量parentStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_">ExampleParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticField3 = <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态代码块中静态变量staticField3被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">staticField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;静态变量staticField2被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField staticField3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法staticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.staticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">静态代码块中静态变量staticField3被初始化</span><br><span class="line">静态变量staticField1被初始化</span><br><span class="line">静态变量staticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>因为在加载 Example 这个子类之前先加载了 ParentExample 这个父类，所以感觉通过子类可以获取父类的静态成员（静态变量和静态方法）。</p>
<p>认证代码如下：</p>
<p>给父类 ParentExaple 加个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">StaticField</span> <span class="variable">parentStaticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;父类的静态变量parentStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> StaticField parentStaticField2;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        parentStaticField2 = <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;父类的静态代码块中静态变量parentStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">parentStaticMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的静态方法parentStaticMethod1被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用父类的静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Example.parentStaticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>调用父类的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Example.parentStaticField3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类的静态变量parentStaticField1被初始化</span><br><span class="line">父类的静态代码块中静态变量parentStaticField2被初始化</span><br><span class="line">父类的静态方法parentStaticMethod1被执行</span><br></pre></td></tr></table></figure>
<p>从结果发现子类可以调用父类的静态成员（静态变量或者静态方法），但是如果只是通过子类调用父类的静态成员（静态变量或者静态方法）并不会加载子类，指挥加载父类。</p>
<h3 id="static-修饰的内部类的加载机制（静态内部类）"><a href="#static-修饰的内部类的加载机制（静态内部类）" class="headerlink" title="static 修饰的内部类的加载机制（静态内部类）"></a>static 修饰的内部类的加载机制（静态内部类）</h3><p>先看看下面的测试代码：</p>
<p>StaticField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticField</span><span class="params">(String string)</span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Outer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StaticField</span> <span class="variable">outerStaticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;外部类静态变量innserStaticField1被初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">StaticField</span> <span class="variable">outerStaticField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;外部类静态变量innserStaticField2被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Innser</span>&#123;</span><br><span class="line">        <span class="keyword">static</span>  <span class="type">StaticField</span> <span class="variable">innserStaticField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;内部类静态变量innserStaticField1被初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">StaticField</span> <span class="variable">innserStaticField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticField</span>(<span class="string">&quot;内部类静态变量innserStaticField2被初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 main 方法只是调用外部类</p>
<p>Main：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取Outer类的静态变量outerStaticField1</span></span><br><span class="line">        System.out.println(Outer.outerStaticField1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类静态变量innserStaticField1被初始化</span><br><span class="line">外部类静态变量innserStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>如果只在 main 方法中调用内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取静态内部类Innser的静态变量innserStaticField1</span></span><br><span class="line">        System.out.println(Outer.Innser.innserStaticField1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">内部类静态变量innserStaticField1被初始化</span><br><span class="line">内部类静态变量innserStaticField2被初始化</span><br><span class="line">StaticField@4554617c</span><br></pre></td></tr></table></figure>
<p>可以看出只调用外部类只会初始加载外部类并不会加载静态内部类，只调用静态内部类只记载静态内部类并不会记载外部类。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
